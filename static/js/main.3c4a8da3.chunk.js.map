{"version":3,"sources":["redux/actions/index.js","redux/store/interactionModes.js","redux/store/debugInitialState.js","components/constantes.js","atoms/currant.js","atoms/label.js","components/hoc/pathComponents.js","components/Lampe.js","components/empty_diode.js","components/pR.js","components/vcapacitor.js","components/nmos.js","components/vee.js","components/vcc.js","components/index.js","redux/store/utils.js","redux/store/dragging.js","redux/store/delete.js","redux/store/pathCreation.js","redux/store/rectangleSelection.js","redux/store/nodeCreation.js","redux/store/anchorHelper.js","redux/store/index.js","container/components.js","atoms/anchor.js","container/anchors.js","atoms/magnet.js","container/magnets.js","container/index.js","redux/store/getCircuitikz.js","container/latexDisplay.js","container/elementOptions.js","App.js","serviceWorker.js","index.js"],"names":["START_DRAGGING","startDragging","x","y","type","STOP_DRAGGING","stopDragging","UPDATE_POSITION","updatePosition","attractor","attracted","shiftPress","START_SELECT","TOGGLE_SELECTION","toggleSelection","objectId","reset","START_CREATE_PATH_ELEMENT","VALIDATE_FIRST_STEP_PATH_ELEMENT_CREATION","INVALIDATE_FIRST_STEP_PATH_ELEMENT_CREATION","SAVE_PATH_ELEMENT_CREATION","START_CREATE_NODE_ELEMENT","ELEMENT_CREATION_NEXT_STEP","SPLIT_ANCHOR","START_RECTANGLE_SELECTION","STOP_RECTANGLE_SELECTION","STACK_SELECTED_ANCHORS","DELETE_ELEMENT","UPDATE_COMPONENT","MODE_SELECT","MODE_DRAG","MODE_CREATE_PATH_ELEMENT","MODE_CREATE_NODE_ELEMENT","MODE_RECTANGLE_SELECTION","defaultCurrant","show","currantText","currantIsForward","currantIsAbove","currantIsAfter","initial_state","mode","selection","adhesivePoints","weakLinks","currentMagnet","pathComponents","byId","id1","id","from","to","currant","id2","id3","label","annotation","mirror","invert","id4","id5","position","angle","id6","positionAnchor","allIds","anchors","anchor1","anchor2","anchor3","anchor4","anchor5","anchor6","isNodePosition","nodeId","anchor7","MULTIPLICATIVE_CONST","R_LEN","getTextAnchor","textAnchor","alignmentBaseline","CurrantArrow","fromCoords","toCoords","ratio","xFrom","yFrom","xTo","yTo","xI","yI","style","fill","stroke","d","transform","transformOrigin","Math","sin","PI","cos","random","isAbove","Label","height","text","xL","yL","withPathAttributes","width","component","props","selected","onMouseDown","sqrt","parseInt","atan2","className","getPathAttributes","element","currantAttribute","direction","getCurrantAttribute","getLabelAttribute","getAnnotationAttribute","r","toFixed","connect","state","dispatch","cx","cy","UNIT_X","UNIT_Y2","wiper_pos","UNIT_Y","capacitor_width","getElementTranslation","positionCoords","showHandles","xAnchor","yAnchor","deltaX","deltaY","gate_height","strokeWidth","STEP","getAnchors","lampe","pR","name","pR_getAnchor","nmos","dx","dy","Cgap","Bgap","Egap","radAngle","Crad","Brad","Erad","distanceC","distanceB","distanceE","nmos_getAnchor","vee","vee_getAnchor","vcc","vcc_getAnchor","vcapacitor","vcapacitor_getAnchor","getDrawer","positionInformations","anchor","coord","getElementAnchors","drawElement","position1","position2","isPath","isMultyPole","components","getAdhesivePoints","elementType","push","forEach","componentUseThisAnchor","anchorId","replaceComponentAnchor","previousAnchorId","newAnchorId","newElement","action","anchorsToMove","selectedId","includes","findIndex","elem","fromId","toId","pile","nodeSeen","pop","length","originalPosition","alreadyMoved","weakLinksToRemove","filter","map","anchorToRemoveID","anchorToUseId","anchorToRemoveIDIndex","remainingAnchors","newByIDElements","slice","newWeakLink","nameAnchor","newMoveX","newMoveY","originalX","originalY","abs","anchorById","deleteElement","componentId","anchorToRemove","arg","elementId","newAnchors","newComponents","startCreatePathElement","newPath","isFromValidated","attractorTo","attractorFrom","validateFirstStepPathElement","movedAfterFromCreation","invalidateFirstStepPathElement","savePathElement","newId_element","uuid","fromAnchor","toAnchor","newWeakLinks","newRectangle","rectangleSelection","x1","y1","x0","y0","isInRectangle","stopRectangleSelection","startRectangleSelection","newNode","startNodeCreation","saveNodeCreation","positionId","stackAnchors","anchorsSelected","movedAnchors","newPosition","index","min","max","splitAnchor","componentsToChange","weakLinksToCopy","linkedAnchorId","linkToCopy","store","createStore","value","draggingUpdatePosition","pathCreationUpdatePosition","nodeCreationUpdatePosition","rectangleSelectionUpdatePosition","svgRef","current","getBoundingClientRect","xOffset","yOffset","event","stopPropagation","ctrlKey","nativeEvent","clientX","clientY","anchorIds","color","useState","isUsed","setIsUsed","onMouseEnter","onMouseLeave","onMouseMove","onMouseUp","isMoving","reduce","accumulator","accu","nameAdhesive","idAdhesive","validateFirstStepPathElementCreation","invalidateFirstStepPathElementCreation","savePathElementCreation","nextStepOfElementCreation","useRef","xmlns","viewBox","background","shiftKey","ref","getCoordId","getCoord","coords","coordId","removeDrawnElements","drawnElements","listeOfId","compareCoord","coordId1","coordId2","endingPaths1","endingPaths","nodeAssociated1","nodeAssociated","endingPaths2","nodeAssociated2","drawPathFromCoord","startCoordId","nbOfCoordinateUsed","elementsToAdd","nbOfCreatedNames","nextName","currantCoordId","currantCoord","nextPaths","startingPaths","arrivingPaths","nextNode","coordIsNew","getCircuitikz","nodeReference","fromCoord","toCoord","fromCoordId","toCoordId","undefined","parent","parentAnchor","associatedIds","positionCoord","positionCoordId","childId","initilizeCoords","nodeNumberOfNames","circuitText","multiAnchorNodeIds","isNode","sort","join","coordsToPlot","Object","keys","idToPlot","indexOf","splice","code","DialogTitle","DialogContent","DialogActions","Button","autoFocus","onClick","navigator","clipboard","writeText","then","copyCode","inputElement","update","ListItem","TextField","onKeyDown","e","onChangeCapture","button","ListItemText","primary","ListItemSecondaryAction","Input","inputProps","step","FormControlLabel","control","Switch","checked","onChange","Checkbox","disabled","target","idOfInterest","options","handleInputChange","updateComponent","List","n","useStyles","makeStyles","theme","root","display","appBar","zIndex","drawer","toolBar","justifyContent","flexShrink","drawerPaper","drawerContainer","overflow","optionDrawer","optionDrawerPaper","content","flexGrow","padding","spacing","pathIds","startSelect","startCreateNodeElement","stackSelectedAnchors","classes","showCode","setShowCode","useEffect","handleKeyDown","key","console","log","document","addEventListener","removeEventListener","tabIndex","CssBaseline","AppBar","Toolbar","Typography","variant","noWrap","Drawer","paper","open","Dialog","onClose","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.3c4a8da3.chunk.js","sourcesContent":["export const START_DRAGGING = \"START_DRAGGING\";\nexport function startDragging(x, y) {\n  return {\n    type: START_DRAGGING,\n    x,\n    y,\n  };\n}\n\nexport const STOP_DRAGGING = \"STOP_DRAGGING\";\nexport function stopDragging() {\n  return {\n    type: STOP_DRAGGING,\n  };\n}\n\nexport const UPDATE_POSITION = \"UPDATE_POSITION\";\nexport function updatePosition({ x, y, attractor, attracted, shiftPress }) {\n  // TODO : id should be remove\n  return {\n    type: UPDATE_POSITION,\n    x,\n    y,\n    attractor: attractor || null,\n    attracted: attracted || null,\n    shiftPress,\n  };\n}\n\nexport const START_SELECT = \"START_SELECT\";\nexport function startSelect() {\n  return {\n    type: START_SELECT,\n  };\n}\n\nexport const TOGGLE_SELECTION = \"TOGGLE_SELECTION\";\nexport function toggleSelection(objectId, reset) {\n  return {\n    type: TOGGLE_SELECTION,\n    objectId,\n    reset,\n  };\n}\n\nexport const START_CREATE_PATH_ELEMENT = \"START_CREATE_PATH_ELEMENT\";\nexport function startCreatePathElement(elementType) {\n  return {\n    type: START_CREATE_PATH_ELEMENT,\n    elementType,\n  };\n}\n\nexport const VALIDATE_FIRST_STEP_PATH_ELEMENT_CREATION =\n  \"VALIDATE_FIRST_STEP_PATH_ELEMENT_CREATION\";\nexport function validateFirstStepPathElementCreation() {\n  return {\n    type: VALIDATE_FIRST_STEP_PATH_ELEMENT_CREATION,\n  };\n}\n\nexport const INVALIDATE_FIRST_STEP_PATH_ELEMENT_CREATION =\n  \"INVALIDATE_FIRST_STEP_PATH_ELEMENT_CREATION\";\nexport function invalidateFirstStepPathElementCreation() {\n  return {\n    type: INVALIDATE_FIRST_STEP_PATH_ELEMENT_CREATION,\n  };\n}\n\nexport const SAVE_PATH_ELEMENT_CREATION = \"SAVE_PATH_ELEMENT_CREATION\";\nexport function savePathElementCreation() {\n  return {\n    type: SAVE_PATH_ELEMENT_CREATION,\n  };\n}\n\nexport const START_CREATE_NODE_ELEMENT = \"START_CREATE_NODE_ELEMENT\";\nexport function startCreateNodeElement(elementType) {\n  return {\n    type: START_CREATE_NODE_ELEMENT,\n    elementType,\n  };\n}\n\nexport const ELEMENT_CREATION_NEXT_STEP = \"ELEMENT_CREATION_NEXT_STEP\";\nexport function nextStepOfElementCreation() {\n  return {\n    type: ELEMENT_CREATION_NEXT_STEP,\n  };\n}\n\nexport const SPLIT_ANCHOR = \"SPLIT_ANCHOR\";\nexport function splitAnchor(anchorId) {\n  return {\n    type: SPLIT_ANCHOR,\n    anchorId: anchorId || null,\n  };\n}\n\nexport const START_RECTANGLE_SELECTION = \"START_RECTANGLE_SELECTION\";\nexport function startRectangleSelection(x, y) {\n  return {\n    type: START_RECTANGLE_SELECTION,\n    x,\n    y,\n  };\n}\n\nexport const STOP_RECTANGLE_SELECTION = \"STOP_RECTANGLE_SELECTION\";\nexport function stopRectangleSelection() {\n  return {\n    type: STOP_RECTANGLE_SELECTION,\n  };\n}\n\nexport const STACK_SELECTED_ANCHORS = \"STACK_SELECTED_ANCHORS\";\nexport function stackSelectedAnchors(direction) {\n  return {\n    type: STACK_SELECTED_ANCHORS,\n    direction,\n  };\n}\n\nexport const DELETE_ELEMENT = \"DELETE_ELEMENT\";\nexport function deleteElement(selection) {\n  return {\n    type: DELETE_ELEMENT,\n    selection,\n  };\n}\n\nexport const UPDATE_COMPONENT = \"UPDATE_COMPONENT\";\nexport function updateComponent(id, name, value) {\n  return {\n    type: UPDATE_COMPONENT,\n    id,\n    name,\n    value,\n  };\n}\n","export const MODE_SELECT = \"MODE_SELECT\";\nexport const MODE_DRAG = \"MODE_DRAG\";\nexport const MODE_CREATE_PATH_ELEMENT = \"MODE_CREATE_PATH_ELEMENT\";\nexport const MODE_CREATE_NODE_ELEMENT = \"MODE_CREATE_NODE_ELEMENT\";\nexport const MODE_RECTANGLE_SELECTION = \"MODE_RECTANGLE_SELECTION\";\n","import { MODE_SELECT } from \"./interactionModes\";\n\nexport const defaultCurrant = {\n  show: false,\n  currantText: \"\",\n  currantIsForward: true,\n  currantIsAbove: true,\n  currantIsAfter: true,\n};\n\nexport const initial_state = {\n  mode: MODE_SELECT,\n  selection: [],\n  adhesivePoints: [],\n  weakLinks: [],\n  currentMagnet: {\n    attractor: null,\n    attracted: null,\n  },\n  pathComponents: {\n    byId: {\n      id1: {\n        id: \"id1\",\n        from: \"anchor1\",\n        to: \"anchor3\",\n        type: \"pR\",\n        currant: { ...defaultCurrant },\n      },\n      id2: {\n        id: \"id2\",\n        from: \"anchor2\",\n        to: \"anchor3\",\n        type: \"empty led\",\n        currant: { ...defaultCurrant },\n      },\n      id3: {\n        id: \"id3\",\n        from: \"anchor4\",\n        to: \"anchor3\",\n        type: \"lampe\",\n        label: \"label\",\n        annotation: \"annotation\",\n        currant: { ...defaultCurrant },\n        mirror: false,\n        invert: false,\n      },\n      id4: {\n        id: \"id4\",\n        from: \"anchor5\",\n        to: \"anchor3\",\n        type: \"lampe\",\n        label: \"label\",\n        annotation: \"annotation\",\n        currant: { ...defaultCurrant },\n        mirror: false,\n        invert: false,\n      },\n      id5: {\n        id: \"id5\",\n        position: \"anchor6\",\n        type: \"nmos\",\n        angle: -45,\n        // positionAnchor: \"B\",\n      },\n      id6: {\n        id: \"id6\",\n        position: \"anchor7\",\n        type: \"nmos\",\n        angle: \"\",\n        positionAnchor: \"\",\n      },\n    },\n    allIds: [\"id1\", \"id2\", \"id3\", \"id4\", \"id5\", \"id6\"],\n  },\n  anchors: {\n    byId: {\n      anchor1: {\n        id: \"anchor1\",\n        x: 10,\n        y: 200,\n      },\n      anchor2: {\n        id: \"anchor2\",\n        x: 500,\n        y: 200,\n      },\n      anchor3: {\n        id: \"anchor3\",\n        x: 250,\n        y: 200,\n      },\n      anchor4: {\n        id: \"anchor4\",\n        x: 250,\n        y: 400,\n      },\n      anchor5: {\n        id: \"anchor5\",\n        x: 250,\n        y: 10,\n      },\n      anchor6: {\n        id: \"anchor6\",\n        x: 100,\n        y: 400,\n        isNodePosition: true,\n        nodeId: \"id5\",\n      },\n      anchor7: {\n        id: \"anchor7\",\n        x: 100,\n        y: 400,\n        isNodePosition: true,\n        nodeId: \"id6\",\n      },\n    },\n    allIds: [\"anchor1\", \"anchor2\", \"anchor3\", \"anchor4\", \"anchor5\"],\n  },\n};\n","export const MULTIPLICATIVE_CONST = 100;\n\nexport const R_LEN = 1.4;\n","import React from \"react\";\n\nconst getTextAnchor = (angle, currantIsAbove) => {\n  if (-5 < angle && angle < 5) {\n    return {\n      textAnchor: \"middle\",\n      alignmentBaseline: currantIsAbove ? \"baseline\" : \"hanging\",\n    };\n  }\n  if (-86 < angle && angle <= -5) {\n    return {\n      textAnchor: currantIsAbove ? \"end\" : \"start\",\n      alignmentBaseline: currantIsAbove ? \"baseline\" : \"hanging\",\n    };\n  }\n  if (-95 < angle && angle <= -86) {\n    return {\n      textAnchor: currantIsAbove ? \"end\" : \"start\",\n      alignmentBaseline: \"middle\",\n    };\n  }\n  if (-176 < angle && angle <= -95) {\n    return {\n      textAnchor: currantIsAbove ? \"end\" : \"start\",\n      alignmentBaseline: currantIsAbove ? \"hanging\" : \"baseline\",\n    };\n  }\n\n  if (angle >= 5 && angle < 86) {\n    return {\n      textAnchor: currantIsAbove ? \"start\" : \"end\",\n      alignmentBaseline: currantIsAbove ? \"baseline\" : \"hanging\",\n    };\n  }\n  if (angle >= 86 && angle < 95) {\n    return {\n      textAnchor: currantIsAbove ? \"start\" : \"end\",\n      alignmentBaseline: \"middle\",\n    };\n  }\n  if (angle >= 95 && angle < 176) {\n    return {\n      textAnchor: currantIsAbove ? \"start\" : \"end\",\n      alignmentBaseline: currantIsAbove ? \"hanging\" : \"baseline\",\n    };\n  }\n  return {\n    textAnchor: \"middle\",\n    alignmentBaseline: currantIsAbove ? \"hanging\" : \"baseline\",\n  };\n};\n\nexport const getCurrantAttribute = ({\n  show,\n  currantText,\n  currantIsForward,\n  currantIsAbove,\n  currantIsAfter,\n}) => {\n  if (!show) {\n    return \"\";\n  }\n  const text = currantText || \"$$$$\";\n  if (!currantIsAfter) {\n    const position = currantIsAbove ? \"^\" : \"_\";\n    const direction = currantIsForward ? \">\" : \"<\";\n    return `i${direction}${position}=${text}`;\n  } else {\n    const position = currantIsAbove ? \"^\" : \"_\";\n    const direction = currantIsForward ? \">\" : \"<\";\n    return `i${position}${direction}=${text}`;\n  }\n};\n\nconst CurrantArrow = ({\n  fromCoords,\n  toCoords,\n  currantText,\n  ratio = null,\n  angle = null,\n  currantIsForward = true,\n  currantIsAbove = true,\n  currantIsAfter = true,\n}) => {\n  if (\n    !fromCoords ||\n    !toCoords ||\n    !currantText ||\n    angle === null ||\n    ratio === null\n  ) {\n    return null;\n  }\n  const { x: xFrom, y: yFrom } = fromCoords;\n  const { x: xTo, y: yTo } = toCoords;\n\n  const xI = currantIsAfter\n    ? xTo + (ratio * (xFrom - xTo)) / 2\n    : xFrom + (ratio * (xTo - xFrom)) / 2;\n  const yI = currantIsAfter\n    ? yTo + (ratio * (yFrom - yTo)) / 2\n    : yFrom + (ratio * (yTo - yFrom)) / 2;\n  const rI = 15;\n\n  return (\n    <g\n      style={{\n        fill: \"black\",\n        stroke: \"none\",\n      }}\n    >\n      <path\n        d={`M ${xI + 0.5 * rI} ${yI} L  ${xI - 0.5 * rI} ${yI + 0.5 * rI} L  ${\n          xI - 0.5 * rI\n        } ${yI - 0.5 * rI} Z`}\n        style={{\n          transform: `rotate(${angle + (currantIsForward ? 0 : 180)}deg)`,\n          transformOrigin: `${xI}px ${yI}px`,\n        }}\n      />\n      <text\n        key={Math.random()}\n        x={\n          xI -\n          (currantIsAbove ? -0.5 * rI : 0.5 * rI) *\n            Math.sin((angle / 180) * Math.PI)\n        }\n        y={\n          yI +\n          (currantIsAbove ? -0.5 * rI : 0.5 * rI) *\n            Math.cos((angle / 180) * Math.PI)\n        }\n        style={{ ...getTextAnchor(angle, currantIsAbove) }}\n      >\n        {currantText}\n      </text>\n    </g>\n  );\n};\n\nexport default CurrantArrow;\n","import React from \"react\";\n\nconst getTextAnchor = (angle, isAbove, x, y) => {\n  if (-20 < angle && angle < 20) {\n    return {\n      textAnchor: \"middle\",\n      alignmentBaseline: isAbove ? \"baseline\" : \"hanging\",\n    };\n  }\n  if (-110 < angle && angle < -70) {\n    return {\n      textAnchor: isAbove ? \"end\" : \"start\",\n      alignmentBaseline: \"middle\",\n    };\n  }\n  if (70 < angle && angle < 110) {\n    return {\n      textAnchor: isAbove ? \"start\" : \"end\",\n      alignmentBaseline: \"middle\",\n    };\n  }\n  if (angle < -160 || angle > 160) {\n    return {\n      textAnchor: \"middle\",\n      alignmentBaseline: isAbove ? \"hanging\" : \"baseline\",\n    };\n  }\n  if (angle <= -20 && angle >= -70) {\n    return {\n      // textAnchor: isAbove ? \"end\" : \"start\",\n      textAnchor: \"middle\",\n      alignmentBaseline: isAbove ? \"baseline\" : \"hanging\",\n      transform: `rotate(${angle}deg)`,\n      transformOrigin: `${x}px ${y}px`,\n    };\n  }\n  if (angle >= 20 && angle <= 70) {\n    return {\n      // textAnchor: isAbove ? \"start\" : \"end\",\n      textAnchor: \"middle\",\n      alignmentBaseline: isAbove ? \"baseline\" : \"hanging\",\n      transform: `rotate(${angle}deg)`,\n      transformOrigin: `${x}px ${y}px`,\n    };\n  }\n  if (angle <= -110 && angle >= -160) {\n    return {\n      // textAnchor: isAbove ? \"end\" : \"start\",\n      textAnchor: \"middle\",\n      alignmentBaseline: isAbove ? \"hanging\" : \"baseline\",\n      transform: `rotate(${angle + 180}deg)`,\n      transformOrigin: `${x}px ${y}px`,\n    };\n  }\n  if (angle >= 110 && angle <= 160) {\n    return {\n      // textAnchor: isAbove ? \"start\" : \"end\",\n      textAnchor: \"middle\",\n      alignmentBaseline: isAbove ? \"hanging\" : \"baseline\",\n      transform: `rotate(${angle + 180}deg)`,\n      transformOrigin: `${x}px ${y}px`,\n    };\n  }\n};\n\nexport const getLabelAttribute = (text, isAbove = true) => {\n  if (!text) {\n    return \"\";\n  }\n  if (!isAbove) {\n    return `l_=${text}`;\n  } else {\n    return `l=${text}`;\n  }\n};\nexport const getAnnotationAttribute = (text, isAbove = false) => {\n  if (!text) {\n    return \"\";\n  }\n  if (!isAbove) {\n    return `a=${text}`;\n  } else {\n    return `a^=${text}`;\n  }\n};\n\nconst gap = 10;\n\nconst Label = ({\n  fromCoords,\n  toCoords,\n  angle = null,\n  height = null,\n  text,\n  isAbove = true,\n}) => {\n  if (!fromCoords || !toCoords || !text || angle === null || height === null) {\n    return null;\n  }\n  const { x: xFrom, y: yFrom } = fromCoords;\n  const { x: xTo, y: yTo } = toCoords;\n\n  const xL =\n    (xFrom + xTo) / 2 +\n    (isAbove ? height + gap : -(height + gap)) *\n      Math.sin((angle / 180) * Math.PI);\n  const yL =\n    (yFrom + yTo) / 2 +\n    (isAbove ? -(height + gap) : height + gap) *\n      Math.cos((angle / 180) * Math.PI);\n\n  return (\n    <g\n      style={{\n        fill: \"black\",\n        stroke: \"none\",\n      }}\n    >\n      <text\n        key={Math.random()}\n        x={xL}\n        y={yL}\n        style={{ ...getTextAnchor(angle, isAbove, xL, yL) }}\n      >\n        {text}\n      </text>\n    </g>\n  );\n};\n\nexport default Label;\n","import React from \"react\";\nimport { MULTIPLICATIVE_CONST } from \"../constantes\";\nimport CurrantArrow, { getCurrantAttribute } from \"../../atoms/currant\";\nimport Label, {\n  getLabelAttribute,\n  getAnnotationAttribute,\n} from \"../../atoms/label\";\n\n// TODO : should allow to have heighTop and heighBottom (cf pR component problem)\n// or a ratio between top and bottom to share the complete heigh\nexport const withPathAttributes = ({ height = 1, width = 1 }) => (\n  component\n) => (props) => {\n  const {\n    fromCoords,\n    toCoords,\n    selected,\n    onMouseDown,\n    currant,\n    label,\n    annotation,\n    mirror,\n    invert,\n  } = props;\n\n  if (!fromCoords || !toCoords) {\n    return null;\n  }\n\n  const { x: xFrom, y: yFrom } = fromCoords;\n  const { x: xTo, y: yTo } = toCoords;\n\n  const d = Math.sqrt((xFrom - xTo) ** 2 + (yFrom - yTo) ** 2);\n  const ratio = (d - width * MULTIPLICATIVE_CONST) / (2 * d); // ratio of the line use by connection\n  const angle = parseInt(\n    (180 * Math.atan2(yTo - yFrom, xTo - xFrom)) / Math.PI\n  );\n\n  return (\n    <g\n      onMouseDown={onMouseDown || null}\n      className={`component ${selected ? \"red\" : \"black\"}`}\n    >\n      <g\n        style={{\n          transform: `translate(${(xFrom + xTo) / 2}px , ${\n            (yFrom + yTo) / 2\n          }px) rotate(${angle}deg)${mirror ? \"scaleY(-1)\" : \"\"}${\n            invert ? \"scaleX(-1)\" : \"\"\n          }`,\n        }}\n      >\n        {component({\n          ...props,\n          x: (xFrom + xTo) / 2,\n          y: (yFrom + yTo) / 2,\n          angle: angle,\n        })}\n      </g>\n\n      {/* draw the line between anchors and the component */}\n      <path\n        d={`M ${xFrom} ${yFrom} L ${xFrom + ratio * (xTo - xFrom)} ${\n          yFrom + ratio * (yTo - yFrom)\n        }`}\n      />\n      <path\n        d={`M ${xTo} ${yTo} L ${xTo + ratio * (xFrom - xTo)} ${\n          yTo + ratio * (yFrom - yTo)\n        }`}\n      />\n\n      {currant && currant.show && (\n        <CurrantArrow\n          fromCoords={fromCoords}\n          toCoords={toCoords}\n          ratio={ratio}\n          angle={angle}\n          {...currant}\n        />\n      )}\n      {label && (\n        <Label\n          fromCoords={fromCoords}\n          toCoords={toCoords}\n          height={0.5 * height * MULTIPLICATIVE_CONST}\n          angle={angle}\n          text={label}\n        />\n      )}\n      {annotation && (\n        <Label\n          fromCoords={fromCoords}\n          toCoords={toCoords}\n          height={0.5 * height * MULTIPLICATIVE_CONST}\n          angle={angle}\n          text={annotation}\n          isAbove={false}\n        />\n      )}\n    </g>\n  );\n};\n\nexport const getPathAttributes = (element) => {\n  const currantAttribute = getCurrantAttribute(element.currant);\n  const label = getLabelAttribute(element.label);\n  const annotation = getAnnotationAttribute(element.annotation);\n\n  return `${label ? `, ${label}` : \"\"}${annotation ? `, ${annotation}` : \"\"}${\n    currantAttribute ? `, ${currantAttribute}` : \"\"\n  }${element.mirror ? \", mirror\" : \"\"}${element.invert ? \", invert\" : \"\"}`;\n};\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport \"./style.scss\";\nimport { MULTIPLICATIVE_CONST, R_LEN } from \"./constantes\";\nimport { withPathAttributes, getPathAttributes } from \"./hoc/pathComponents\";\n\nconst width = 0.6;\nconst height = 0.6;\nconst R = 0.6 * 0.5 * MULTIPLICATIVE_CONST;\nconst r = (0.7071 * R).toFixed(3);\n\n// If id => it's from scene\n// If no id => it's from adding\nconst mapStateToProps = (state, props) => {\n  return props.id\n    ? {\n        mode: state.mode,\n        // allows to create components directly without using the store\n        fromCoords: state.anchors.byId[props.from],\n        toCoords: state.anchors.byId[props.to],\n      }\n    : {};\n};\n\nconst mapDispatchToProps = (dispatch) => {\n  return {};\n};\n\nconst Lampe = ({}) => {\n  return (\n    <>\n      <circle cx={0} cy={0} r={R} />\n      <path d={`M -${r} -${r} L ${r} ${r} M -${r} ${r} L ${r} -${r}`} />\n    </>\n  );\n};\n\nexport const drawer = (element) => {\n  return `to[lamp${getPathAttributes(element)}] `;\n};\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(withPathAttributes({ width, height })(Lampe));\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport \"./style.scss\";\nimport { MULTIPLICATIVE_CONST, R_LEN } from \"./constantes\";\nimport { withPathAttributes, getPathAttributes } from \"./hoc/pathComponents\";\n\nconst height = 0.5;\nconst width = 0.4;\n\nconst UNIT_X = 0.5 * width * MULTIPLICATIVE_CONST;\nconst UNIT_Y = 0.5 * height * MULTIPLICATIVE_CONST;\n\n// If id => it's from scene\n// If no id => it's from adding\nconst mapStateToProps = (state, props) => {\n  return props.id\n    ? {\n        mode: state.mode,\n        // allows to create components directly without using the store\n        fromCoords: state.anchors.byId[props.from],\n        toCoords: state.anchors.byId[props.to],\n      }\n    : {};\n};\n\nconst EmptyDiode = ({}) => {\n  return (\n    <>\n      <path\n        d={`M ${UNIT_X} 0 L ${-UNIT_X} ${-UNIT_Y} L ${-UNIT_X} ${UNIT_Y} Z`}\n      />\n      <path d={`M ${UNIT_X} ${UNIT_Y} L ${UNIT_X} ${-UNIT_Y}`} />\n    </>\n  );\n};\n\nexport const drawer = (element) => {\n  return `to[empty diode${getPathAttributes(element)}] `;\n};\n\nexport default connect(mapStateToProps)(\n  withPathAttributes({ width, height })(EmptyDiode)\n);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport \"./style.scss\";\nimport { MULTIPLICATIVE_CONST, R_LEN } from \"./constantes\";\nimport { withPathAttributes, getPathAttributes } from \"./hoc/pathComponents\";\n\nconst height = 0.8;\nconst height_2 = 0.3;\nconst width = 0.8;\n\nconst UNIT_X = 0.5 * width * MULTIPLICATIVE_CONST;\nconst UNIT_Y2 = 0.5 * height_2 * MULTIPLICATIVE_CONST;\nconst UNIT_Y = 0.5 * height * MULTIPLICATIVE_CONST;\n\nexport const getAnchor = ({ fromCoords, toCoords }) => {\n  const { x: xFrom, y: yFrom } = fromCoords;\n  const { x: xTo, y: yTo } = toCoords;\n\n  const angle = Math.atan2(yTo - yFrom, xTo - xFrom);\n\n  const x = (xFrom + xTo) / 2 + 55 * Math.sin(angle);\n  const y = (yFrom + yTo) / 2 - 55 * Math.cos(angle);\n  return [{ name: \"wiper\", x, y }];\n};\n\n// If id => it's from scene\n// If no id => it's from adding\nconst mapStateToProps = (state, props) => {\n  return props.id\n    ? {\n        mode: state.mode,\n        // allows to create components directly without using the store\n        fromCoords: state.anchors.byId[props.from],\n        toCoords: state.anchors.byId[props.to],\n      }\n    : {};\n};\n\nconst PR = ({ wiper_pos = 0.5 }) => {\n  return (\n    <>\n      <path\n        d={`M ${(-6 / 6) * UNIT_X} 0 L ${(-5 / 6) * UNIT_X} ${-UNIT_Y2} L ${\n          (-3 / 6) * UNIT_X\n        } ${UNIT_Y2} L ${(-1 / 6) * UNIT_X} ${-UNIT_Y2} L ${\n          (1 / 6) * UNIT_X\n        } ${UNIT_Y2} L ${(3 / 6) * UNIT_X} ${-UNIT_Y2} L ${\n          (5 / 6) * UNIT_X\n        } ${UNIT_Y2} L ${(6 / 6) * UNIT_X} 0`}\n      />\n      <path\n        d={`M ${\n          -(0.5 - wiper_pos) * width * MULTIPLICATIVE_CONST\n        } ${-UNIT_Y} L ${\n          -(0.5 - wiper_pos) * width * MULTIPLICATIVE_CONST\n        } ${-UNIT_Y2}`}\n      />\n    </>\n  );\n};\n\nexport const drawer = (element) => {\n  return `to[pR${getPathAttributes(element)}] `;\n};\n\nexport default connect(mapStateToProps)(\n  withPathAttributes({ width, height })(PR)\n);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport \"./style.scss\";\nimport { R_LEN, MULTIPLICATIVE_CONST } from \"./constantes\";\nimport { withPathAttributes, getPathAttributes } from \"./hoc/pathComponents\";\n\nconst height = 0.6;\nconst width = 0.5;\nconst capacitor_width = 0.4;\n\nconst UNIT_X = 0.5 * width * MULTIPLICATIVE_CONST;\nconst UNIT_Y = 0.5 * height * MULTIPLICATIVE_CONST;\n\nconst STEP = capacitor_width * UNIT_X;\n\nexport const getAnchor = ({ fromCoords, toCoords }) => {\n  const { x: xFrom, y: yFrom } = fromCoords;\n  const { x: xTo, y: yTo } = toCoords;\n\n  const angle = Math.atan2(yTo - yFrom, xTo - xFrom);\n\n  const x = (xFrom + xTo) / 2 + 55 * Math.sin(angle);\n  const y = (yFrom + yTo) / 2 - 55 * Math.cos(angle);\n  return [{ name: \"wiper\", x, y }];\n};\n\n// If id => it's from scene\n// If no id => it's from adding\nconst mapStateToProps = (state, props) => {\n  return props.id\n    ? {\n        mode: state.mode,\n        // allows to create components directly without using the store\n        fromCoords: state.anchors.byId[props.from],\n        toCoords: state.anchors.byId[props.to],\n      }\n    : {};\n};\n\nconst Vcapacitor = ({}) => {\n  return (\n    <>\n      <path d={`M  ${-STEP} ${-UNIT_Y} L ${-STEP} ${UNIT_Y}`} />\n      <path d={`M  ${STEP} ${-UNIT_Y} L ${STEP} ${UNIT_Y}`} />\n      <path d={`M ${-UNIT_X} ${-UNIT_Y} L ${UNIT_X} ${UNIT_Y}`} />\n    </>\n  );\n};\n\nexport const drawer = (element) => {\n  return `to[variable capacitor${getPathAttributes(element)}] `;\n};\n\nexport default connect(mapStateToProps)(\n  withPathAttributes({ width: capacitor_width / 2, height })(Vcapacitor)\n);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport \"./style.scss\";\n\nimport { MULTIPLICATIVE_CONST, R_LEN } from \"./constantes\";\n\nconst width = 0.7;\nconst gate_height = 0.35;\nconst base_height = 0.5;\n// const conn_height = 0;\nconst height = 1.1;\nconst base_width = 0.5;\nconst gate_width = 0.62;\n// const arrow_pos = 0.6;\n// const bodydiode_scale = 0.3;\n// const bodydiode_distance = 0.3;\n// const bodydiode_conn = 0.6;\n// const curr_direction = 1;\n\nconst UNIT_X = width * MULTIPLICATIVE_CONST;\nconst UNIT_Y = 0.5 * height * MULTIPLICATIVE_CONST;\n\nconst getElementTranslation = (positionAnchor) => {\n  switch (positionAnchor) {\n    case \"B\":\n      return { x: UNIT_X, y: 0 };\n    case \"C\":\n      return { x: 0, y: UNIT_Y };\n    case \"E\":\n      return { x: 0, y: -UNIT_Y };\n    default:\n      return { x: 0, y: 0 };\n  }\n};\n\nexport const getAnchor = ({ positionAnchor, angle = 0, positionCoords }) => {\n  const { x, y } = positionCoords;\n\n  const { x: dx, y: dy } = getElementTranslation(positionAnchor);\n\n  const Cgap = getElementTranslation(\"C\");\n  const Bgap = getElementTranslation(\"B\");\n  const Egap = getElementTranslation(\"E\");\n  const radAngle = (Math.PI * angle) / 180;\n\n  const Crad = Math.atan2(dy - Cgap.y, dx - Cgap.x);\n  const Brad = Math.atan2(dy - Bgap.y, dx - Bgap.x);\n  const Erad = Math.atan2(dy - Egap.y, dx - Egap.x);\n\n  const distanceC = Math.sqrt((Cgap.x - dx) ** 2 + (Cgap.y - dy) ** 2);\n  const distanceB = Math.sqrt((Bgap.x - dx) ** 2 + (Bgap.y - dy) ** 2);\n  const distanceE = Math.sqrt((Egap.x - dx) ** 2 + (Egap.y - dy) ** 2);\n\n  return [\n    {\n      name: \"C\",\n      x: x + Math.cos(-radAngle + Crad) * distanceC,\n      y: y + Math.sin(-radAngle + Crad) * distanceC,\n    },\n    {\n      name: \"B\",\n      x: x + Math.cos(-radAngle + Brad) * distanceB,\n      y: y + Math.sin(-radAngle + Brad) * distanceB,\n    },\n    {\n      name: \"E\",\n      x: x + Math.cos(-radAngle + Erad) * distanceE,\n      y: y + Math.sin(-radAngle + Erad) * distanceE,\n    },\n  ];\n};\n\n// If id => it's from scene\n// If no id => it's from adding\nconst mapStateToProps = (state, props) => {\n  return props.id\n    ? {\n        mode: state.mode,\n        // allows to create components directly without using the store\n        positionCoords: state.anchors.byId[props.position],\n      }\n    : {};\n};\n\nconst NMOS = ({\n  positionCoords,\n  positionAnchor = \"\",\n  angle = 0,\n  mode,\n  selected,\n  showHandles,\n  id,\n  onMouseDown,\n}) => {\n  if (!positionCoords) {\n    return null;\n  }\n  const { x: xAnchor, y: yAnchor } = positionCoords;\n  const { x: deltaX, y: deltaY } = getElementTranslation(positionAnchor);\n\n  return (\n    <g\n      onMouseDown={onMouseDown || null}\n      className={`component ${selected ? \"red\" : \"black\"}`}\n    >\n      <g\n        style={{\n          transform: `translate(${xAnchor}px , ${yAnchor}px) rotate(${-angle}deg)`,\n        }}\n      >\n        <g\n          style={{\n            transform: `translate(${deltaX}px , ${deltaY}px)`,\n          }}\n        >\n          <path\n            d={`M ${0} ${-UNIT_Y} \n                  L ${0} ${-gate_height * UNIT_Y}\n                  L ${-base_width * UNIT_X} ${-gate_height * UNIT_Y}`}\n          />\n          <path\n            d={`M ${-base_width * UNIT_X} ${-base_height * UNIT_Y}\n                  L ${-base_width * UNIT_X} ${base_height * UNIT_Y}\n                  L ${-base_width * UNIT_X} ${gate_height * UNIT_Y}\n                  L ${0} ${gate_height * UNIT_Y}\n                  L ${0} ${UNIT_Y}`}\n          />\n          <path\n            d={`M ${-gate_width * UNIT_X} ${-gate_height * UNIT_Y}\n                  L ${-gate_width * UNIT_X} ${gate_height * UNIT_Y}`}\n            style={{ strokeWidth: 2 }}\n          />\n          <path\n            d={`M ${-gate_width * UNIT_X} 0\n                      L ${-UNIT_X} 0`}\n          />\n        </g>\n      </g>\n    </g>\n  );\n};\n\nexport const drawer = (element, positionInformations, name = null) => {\n  const { x, y, position, anchor } = positionInformations;\n\n  const coord = position\n    ? `(${position})`\n    : `(${((x / MULTIPLICATIVE_CONST) * R_LEN).toFixed(2)}, ${(\n        (-y / MULTIPLICATIVE_CONST) *\n        R_LEN\n      ).toFixed(2)})`;\n\n  return `\\\\draw ${coord} node[nmos${anchor ? \" ,anchor=\" + anchor : \"\"}${\n    element.angle && element.angle !== 0 ? \" ,rotate=\" + element.angle : \"\"\n  }]${name ? `(${name})` : \"\"}{};`;\n};\n\nexport default connect(mapStateToProps)(NMOS);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport \"./style.scss\";\n\nimport { MULTIPLICATIVE_CONST, R_LEN } from \"./constantes\";\n\nconst width = 0.2;\nconst STEP = width * R_LEN * MULTIPLICATIVE_CONST;\n\nexport const getAnchor = ({ positionCoords }) => {\n  const { x, y } = positionCoords;\n\n  return [\n    {\n      name: \"C\",\n      x: x,\n      y: y,\n    },\n  ];\n};\n\n// If id => it's from scene\n// If no id => it's from adding\nconst mapStateToProps = (state, props) => {\n  return props.id\n    ? {\n        // allows to create components directly without using the store\n        positionCoords: state.anchors.byId[props.position],\n      }\n    : {};\n};\n\nconst VEE = ({ positionCoords, angle = 0, selected, onMouseDown }) => {\n  if (!positionCoords) {\n    return null;\n  }\n  const { x: xAnchor, y: yAnchor } = positionCoords;\n\n  return (\n    <g\n      onMouseDown={onMouseDown || null}\n      className={`component ${selected ? \"red\" : \"black\"}`}\n    >\n      <g\n        style={{\n          transform: `translate(${xAnchor}px , ${yAnchor}px) rotate(${-angle}deg)`,\n        }}\n      >\n        <path\n          d={`M ${-0.5 * STEP} ${0.8 * STEP}\n                L 0 ${1.5 * STEP}\n                L ${0.5 * STEP} ${0.8 * STEP}`}\n        />\n        <path\n          d={`M 0 0\n                L 0 ${1.5 * STEP}`}\n        />\n      </g>\n    </g>\n  );\n};\n\nexport const drawer = (element) => {\n  return `node[vee]{}`;\n};\n\nexport default connect(mapStateToProps)(VEE);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport \"./style.scss\";\n\nimport { MULTIPLICATIVE_CONST, R_LEN } from \"./constantes\";\n\nconst width = 0.2;\n\nconst STEP = width * R_LEN * MULTIPLICATIVE_CONST;\n\nexport const getAnchor = ({ positionCoords }) => {\n  const { x, y } = positionCoords;\n\n  return [\n    {\n      name: \"C\",\n      x: x,\n      y: y,\n    },\n  ];\n};\n\n// If id => it's from scene\n// If no id => it's from adding\nconst mapStateToProps = (state, props) => {\n  return props.id\n    ? {\n        // allows to create components directly without using the store\n        positionCoords: state.anchors.byId[props.position],\n      }\n    : {};\n};\n\nconst VCC = ({ positionCoords, angle = 0, selected, onMouseDown }) => {\n  if (!positionCoords) {\n    return null;\n  }\n  const { x: xAnchor, y: yAnchor } = positionCoords;\n\n  return (\n    <g\n      onMouseDown={onMouseDown || null}\n      className={`component ${selected ? \"red\" : \"black\"}`}\n    >\n      <g\n        style={{\n          transform: `translate(${xAnchor}px , ${yAnchor}px) rotate(${-angle}deg)`,\n        }}\n      >\n        <path\n          d={`M ${-0.5 * STEP} ${-0.8 * STEP}\n                L 0 ${-1.5 * STEP}\n                L ${0.5 * STEP} ${-0.8 * STEP}`}\n        />\n        <path\n          d={`M 0 0\n                L 0 ${-1.5 * STEP}`}\n        />\n      </g>\n    </g>\n  );\n};\n\nexport const drawer = (element) => {\n  return `node[vcc]{}`;\n};\n\nexport default connect(mapStateToProps)(VCC);\n","import React from \"react\";\nimport Lampe, { drawer as lampeDrawer } from \"./Lampe\";\nimport EmptyDiode, { drawer as emptyDiodeDrawer } from \"./empty_diode\";\nimport PR, { getAnchor as pR_getAnchor, drawer as pRDrawer } from \"./pR\";\nimport Vcapacitor, {\n  getAnchor as vcapacitor_getAnchor,\n  drawer as vcapacitorDrawer,\n} from \"./vcapacitor\";\nimport NMOS, {\n  getAnchor as nmos_getAnchor,\n  drawer as nmosDrawer,\n} from \"./nmos\";\nimport VEE, { getAnchor as vee_getAnchor, drawer as veeDrawer } from \"./vee\";\nimport VCC, { getAnchor as vcc_getAnchor, drawer as vccDrawer } from \"./vcc\";\n\nconst getAnchors = {\n  lampe: () => [],\n  \"empty led\": () => [],\n  pR: (props) => pR_getAnchor(props),\n  nmos: (props) => nmos_getAnchor(props),\n  vee: (props) => vee_getAnchor(props),\n  vcc: (props) => vcc_getAnchor(props),\n  vcapacitor: (props) => vcapacitor_getAnchor(props),\n};\n\nconst getDrawer = {\n  lampe: lampeDrawer,\n  \"empty led\": emptyDiodeDrawer,\n  pR: pRDrawer,\n  nmos: nmosDrawer,\n  vee: veeDrawer,\n  vcc: vccDrawer,\n  vcapacitor: vcapacitorDrawer,\n};\n\nexport const getElementAnchors = (element) => {\n  return getAnchors[element.type](element);\n};\n\nexport const drawElement = (element, position1, position2) => {\n  return getDrawer[element.type](element, position1, position2);\n};\n\nexport const isPath = {\n  lampe: true,\n  \"empty led\": true,\n  pR: true,\n  nmos: false,\n  vee: false,\n  vcc: false,\n  vcapacitor: true,\n};\n\nexport const isMultyPole = {\n  lampe: false,\n  \"empty led\": false,\n  pR: false,\n  nmos: true,\n  vee: false,\n  vcc: false,\n  vcapacitor: false,\n};\n\nconst components = {\n  lampe: (props) => <Lampe key={props.id} {...props} />,\n  \"empty led\": (props) => <EmptyDiode key={props.id} {...props} />,\n  pR: (props) => <PR key={props.id} {...props} />,\n  nmos: (props) => <NMOS key={props.id} {...props} />,\n  vee: (props) => <VEE key={props.id} {...props} />,\n  vcc: (props) => <VCC key={props.id} {...props} />,\n  vcapacitor: (props) => <Vcapacitor key={props.id} {...props} />,\n};\n\nexport default components;\n","import { getElementAnchors, isPath } from \"../../components\";\n\nexport const getAdhesivePoints = (elementType) => {\n  const adhesivePoints = [];\n  if (isPath[elementType]) {\n    adhesivePoints.push({\n      type: \"ANCHOR\",\n      id: null,\n      dx: 0,\n      dy: 0,\n    });\n  }\n\n  const elementAnchors = getElementAnchors({\n    type: elementType,\n    fromCoords: { x: 0, y: 0 },\n    toCoords: { x: 0, y: 0 },\n    positionCoords: { x: 0, y: 0 },\n  });\n\n  elementAnchors.forEach(({ x, y, name }) => {\n    adhesivePoints.push({\n      type: isPath[elementType] ? \"PATH\" : \"NODE\", // TODO use constant file\n      name: name,\n      id: null,\n      dx: -x,\n      dy: -y,\n    });\n  });\n\n  return adhesivePoints;\n};\n\nexport const componentUseThisAnchor = (element, anchorId) => {\n  if (element.from && element.from === anchorId) {\n    return true;\n  }\n  if (element.to && element.to === anchorId) {\n    return true;\n  }\n  if (element.position && element.position === anchorId) {\n    return true;\n  }\n  return false;\n};\n\nexport const replaceComponentAnchor = (\n  element,\n  previousAnchorId,\n  newAnchorId\n) => {\n  const newElement = { ...element };\n  if (element.from && element.from === previousAnchorId) {\n    newElement.from = newAnchorId;\n  }\n  if (element.to && element.to === previousAnchorId) {\n    newElement.to = newAnchorId;\n  }\n  if (element.position && element.position === previousAnchorId) {\n    newElement.position = newAnchorId;\n  }\n  return { ...newElement };\n};\n\nexport const isInRectangle = ({ x, y }, { x0, y0, x1, y1 }) => {\n  return (\n    Math.abs(x - x0) + Math.abs(x - x1) <= Math.abs(x1 - x0) &&\n    Math.abs(y - y0) + Math.abs(y - y1) <= Math.abs(y1 - y0)\n  );\n};\n\nexport const isAnchor = (state, id) =>\n  id !== null && state.anchors.allIds.includes(id);\n","import { getElementAnchors } from \"../../components\";\n\nimport { replaceComponentAnchor } from \"./utils\";\n\nimport { MODE_DRAG, MODE_SELECT } from \"./interactionModes\";\n\nexport const startDragging = (state, action) => {\n  const anchorsToMove = [];\n  const adhesivePoints = [];\n\n  state.selection.forEach((selectedId) => {\n    if (state.anchors.allIds.includes(selectedId)) {\n      if (adhesivePoints.findIndex((elem) => elem.id === selectedId) === -1) {\n        adhesivePoints.push({\n          type: \"ANCHOR\",\n          id: selectedId,\n          dx: action.x - state.anchors.byId[selectedId].x,\n          dy: action.y - state.anchors.byId[selectedId].y,\n        });\n      }\n    } else if (state.pathComponents.allIds.includes(selectedId)) {\n      const anchors = getElementAnchors({\n        ...state.pathComponents.byId[selectedId],\n        fromCoords:\n          state.pathComponents.byId[selectedId].from &&\n          state.anchors.byId[state.pathComponents.byId[selectedId].from],\n        toCoords:\n          state.pathComponents.byId[selectedId].to &&\n          state.anchors.byId[state.pathComponents.byId[selectedId].to],\n        positionCoords:\n          state.pathComponents.byId[selectedId].position &&\n          state.anchors.byId[state.pathComponents.byId[selectedId].position],\n      });\n\n      anchors.forEach(({ x, y, name }) => {\n        adhesivePoints.push({\n          type: state.pathComponents.byId[selectedId].position\n            ? \"NODE\"\n            : \"PATH\", // TODO use constant file\n          name: name,\n          id: selectedId,\n          dx: action.x - x,\n          dy: action.y - y,\n        });\n      });\n      if (\n        state.pathComponents.byId[selectedId].from &&\n        adhesivePoints.findIndex(\n          (elem) => elem.id === state.pathComponents.byId[selectedId].from\n        ) === -1\n      ) {\n        //the from anchor is new\n        const fromId = state.pathComponents.byId[selectedId].from;\n        adhesivePoints.push({\n          type: \"ANCHOR\", // TODO use constant file\n          id: fromId,\n          dx: action.x - state.anchors.byId[fromId].x,\n          dy: action.y - state.anchors.byId[fromId].y,\n        });\n      }\n      if (\n        state.pathComponents.byId[selectedId].to &&\n        adhesivePoints.findIndex(\n          (elem) => elem.id === state.pathComponents.byId[selectedId].to\n        ) === -1\n      ) {\n        //the to anchor is new\n        const toId = state.pathComponents.byId[selectedId].to;\n        adhesivePoints.push({\n          type: \"ANCHOR\",\n          id: toId,\n          dx: action.x - state.anchors.byId[toId].x,\n          dy: action.y - state.anchors.byId[toId].y,\n        });\n      }\n    }\n  });\n\n  const pile = [...state.selection];\n  const nodeSeen = [];\n  while (pile.length > 0) {\n    const selectedId = pile.pop();\n    if (state.pathComponents.allIds.includes(selectedId)) {\n      if (\n        state.pathComponents.byId[selectedId].from &&\n        !anchorsToMove.includes(state.pathComponents.byId[selectedId].from)\n      ) {\n        anchorsToMove.push(state.pathComponents.byId[selectedId].from);\n      }\n      if (\n        state.pathComponents.byId[selectedId].to &&\n        !anchorsToMove.includes(state.pathComponents.byId[selectedId].to)\n      ) {\n        anchorsToMove.push(state.pathComponents.byId[selectedId].to);\n      }\n      if (state.pathComponents.byId[selectedId].position) {\n        if (\n          !anchorsToMove.includes(\n            state.pathComponents.byId[selectedId].position\n          )\n        ) {\n          pile.push(state.pathComponents.byId[selectedId].position);\n        }\n        if (!nodeSeen.includes(selectedId)) {\n          nodeSeen.push(selectedId);\n          state.weakLinks.forEach(({ anchorId, nodeId }) => {\n            if (nodeId === selectedId && !anchorsToMove.includes(anchorId)) {\n              pile.push(anchorId);\n            }\n          });\n        }\n      }\n    } else {\n      if (!anchorsToMove.includes(selectedId)) {\n        anchorsToMove.push(selectedId);\n\n        if (state.anchors.byId[selectedId].isNodePosition) {\n          pile.push(state.anchors.byId[selectedId].nodeId);\n        }\n      }\n    }\n  }\n\n  return {\n    ...state,\n    mode: MODE_DRAG,\n    anchorsToMove: [...anchorsToMove],\n    adhesivePoints: [...adhesivePoints],\n    originalPosition: { x: action.x, y: action.y },\n    alreadyMoved: { x: 0, y: 0 },\n    weakLinksToRemove: [\n      ...state.weakLinks\n        .filter(\n          ({ anchorId, nodeId }) =>\n            anchorsToMove.includes(anchorId) &&\n            !anchorsToMove.includes(state.pathComponents.byId[nodeId].position)\n        )\n        .map(({ anchorId, nodeId }) => anchorId + \"-\" + nodeId),\n    ],\n  };\n};\n\nexport const stopDragging = (state, action) => {\n  if (\n    state.currentMagnet.attractor &&\n    state.currentMagnet.attracted &&\n    state.currentMagnet.attracted.type === \"ANCHOR\" &&\n    state.currentMagnet.attractor.type === \"ANCHOR\"\n  ) {\n    // we need to fusion those anchors\n    const anchorToRemoveID = state.currentMagnet.attracted.id;\n    const anchorToUseId = state.currentMagnet.attractor.id;\n\n    // remove anchor\n    const anchorToRemoveIDIndex = state.anchors.allIds.findIndex(\n      (id) => id === anchorToRemoveID\n    );\n    const {\n      [anchorToRemoveID]: anchorToRemove,\n      ...remainingAnchors\n    } = state.anchors.byId;\n\n    //const update elements\n    const newByIDElements = {};\n    state.pathComponents.allIds.forEach((id) => {\n      newByIDElements[id] = replaceComponentAnchor(\n        state.pathComponents.byId[id],\n        anchorToRemoveID,\n        anchorToUseId\n      );\n    });\n\n    return {\n      ...state,\n      anchors: {\n        byId: { ...remainingAnchors },\n        allIds: [\n          ...state.anchors.allIds.slice(0, anchorToRemoveIDIndex),\n          ...state.anchors.allIds.slice(anchorToRemoveIDIndex + 1),\n        ],\n      },\n      pathComponents: {\n        ...state.pathComponents,\n        byId: { ...newByIDElements },\n      },\n      mode: MODE_SELECT,\n      anchorsToMove: [],\n      originalPosition: {},\n      alreadyMoved: {},\n      weakLinksToRemove: [],\n      weakLinks: [\n        ...state.weakLinks.filter(\n          ({ anchorId, nodeId }) =>\n            !state.weakLinksToRemove.includes(anchorId + \"-\" + nodeId)\n        ),\n      ],\n    };\n  }\n\n  if (\n    state.currentMagnet.attractor &&\n    state.currentMagnet.attracted &&\n    state.currentMagnet.attracted.type !== \"PATH\" &&\n    state.currentMagnet.attractor.type !== \"PATH\"\n  ) {\n    const newWeakLink = [];\n\n    if (\n      state.currentMagnet.attracted.type === \"NODE\" &&\n      state.currentMagnet.attractor.type === \"NODE\"\n    ) {\n      newWeakLink.push({\n        anchorId:\n          state.pathComponents.byId[state.currentMagnet.attracted.id].position,\n        nodeId: state.currentMagnet.attractor.id,\n        name: state.currentMagnet.attractor.name,\n        nameAnchor: state.currentMagnet.attracted.name,\n      });\n    } else {\n      const nodeId =\n        state.currentMagnet.attracted.type === \"NODE\"\n          ? state.currentMagnet.attracted.id\n          : state.currentMagnet.attractor.id;\n      const anchorId =\n        state.currentMagnet.attracted.type === \"ANCHOR\"\n          ? state.currentMagnet.attracted.id\n          : state.currentMagnet.attractor.id;\n      const name =\n        state.currentMagnet.attracted.type === \"NODE\"\n          ? state.currentMagnet.attracted.name\n          : state.currentMagnet.attractor.name;\n\n      newWeakLink.push({\n        anchorId: anchorId,\n        nodeId: nodeId,\n        name: name,\n      });\n    }\n    return {\n      ...state,\n      mode: MODE_SELECT,\n      anchorsToMove: [],\n      originalPosition: {},\n      alreadyMoved: {},\n      weakLinksToRemove: [],\n      weakLinks: [\n        ...state.weakLinks.filter(\n          ({ anchorId, nodeId }) =>\n            !state.weakLinksToRemove.includes(anchorId + \"-\" + nodeId)\n        ),\n        ...newWeakLink,\n      ],\n    };\n  }\n\n  return {\n    ...state,\n    mode: MODE_SELECT,\n    anchorsToMove: [],\n    originalPosition: {},\n    alreadyMoved: {},\n\n    weakLinksToRemove: [],\n\n    weakLinks: [\n      ...state.weakLinks.filter(\n        ({ anchorId, nodeId }) =>\n          !state.weakLinksToRemove.includes(anchorId + \"-\" + nodeId)\n      ),\n    ],\n  };\n};\n\nexport const updatePosition = (state, action) => {\n  const { x, y, shiftPress } = action;\n  const { x: originalX, y: originalY } = state.originalPosition;\n\n  let newMoveX, newMoveY;\n  // if shift is pressed only allow to move along x or y axis\n  if (shiftPress) {\n    if (Math.abs(x - originalX) > Math.abs(y - originalY)) {\n      newMoveX = x - originalX;\n      newMoveY = 0;\n    } else {\n      newMoveX = 0;\n      newMoveY = y - originalY;\n    }\n  } else {\n    newMoveX = x - originalX;\n    newMoveY = y - originalY;\n  }\n\n  const anchorById = state.anchors.byId;\n  state.anchorsToMove.forEach((anchorId) => {\n    anchorById[anchorId] = {\n      ...anchorById[anchorId],\n      x: anchorById[anchorId].x + newMoveX - state.alreadyMoved.x,\n      y: anchorById[anchorId].y + newMoveY - state.alreadyMoved.y,\n    };\n  });\n\n  return {\n    ...state,\n    anchors: {\n      ...state.anchors,\n      byId: { ...anchorById },\n    },\n    alreadyMoved: {\n      x: newMoveX,\n      y: newMoveY,\n    },\n  };\n};\n","import { componentUseThisAnchor } from \"./utils\";\n\nconst deleteElement = (state, action) => {\n  const selection = action.selection;\n  if (\n    selection.length === 1 &&\n    state.pathComponents.allIds.includes(selection[0])\n  ) {\n    // we only consider the deletion of a component (not anchors)\n    const componentId = selection[0];\n\n    const anchorToChange = [\"from\", \"to\", \"position\"]\n      .map((arg) => state.pathComponents.byId[componentId][arg])\n      .filter((id) => !!id);\n\n    // get the list of of ids of anchors that are not anymore used by components\n    const anchorToRemove = anchorToChange.filter((anchorId) => {\n      return (\n        state.pathComponents.allIds.filter((elementId) =>\n          componentUseThisAnchor(state.pathComponents.byId[elementId], anchorId)\n        ).length === 1\n      );\n    });\n\n    const newAnchors = { ...state.anchors.byId };\n    anchorToRemove.forEach((id) => delete newAnchors[id]);\n\n    const newComponents = { ...state.pathComponents.byId };\n    delete newComponents[componentId];\n    return {\n      ...state,\n      pathComponents: {\n        allIds: [\n          ...state.pathComponents.allIds.filter((id) => id !== componentId),\n        ],\n        byId: { ...newComponents },\n      },\n      anchors: {\n        byId: { ...newAnchors },\n        allIds: [\n          ...state.anchors.allIds.filter((id) => !anchorToRemove.includes(id)),\n        ],\n      },\n      weakLinks: [\n        ...state.weakLinks.filter(\n          ({ anchorId, nodeId, name }) =>\n            nodeId !== componentId && !anchorToRemove.includes(anchorId)\n        ),\n      ],\n    };\n  } else {\n    return state;\n  }\n};\n\nexport default deleteElement;\n","import { getAdhesivePoints, isAnchor } from \"./utils\";\nimport { defaultCurrant } from \"./debugInitialState\";\nimport { MODE_CREATE_PATH_ELEMENT } from \"./interactionModes\";\n\nimport { v4 as uuid } from \"uuid\";\n\nexport const startCreatePathElement = (state, action) => {\n  return {\n    ...state,\n    selection: [],\n    adhesivePoints: [...getAdhesivePoints(action.elementType)],\n    mode: MODE_CREATE_PATH_ELEMENT,\n    newPath: {\n      elementType: action.elementType,\n      isFromValidated: false,\n      from: { x: null, y: null },\n      to: { x: null, y: null },\n      attractorTo: null,\n      attractorFrom: null,\n    },\n  };\n};\n\nexport const validateFirstStepPathElement = (state, action) => {\n  return {\n    ...state,\n    newPath: {\n      ...state.newPath,\n      attractorFrom: state.currentMagnet.attractor && {\n        ...state.currentMagnet.attractor,\n      },\n      to: { x: null, y: null },\n      attractorTo: null,\n      isFromValidated: true,\n      movedAfterFromCreation: false,\n    },\n  };\n};\n\nexport const invalidateFirstStepPathElement = (state, action) => {\n  if (state.newPath.movedAfterFromCreation && state.newPath.isFromValidated) {\n    return {\n      ...state,\n      newPath: {\n        ...state.newPath,\n        from: { ...state.newPath.to },\n        attractorFrom: state.newPath.attractorTo && {\n          ...state.newPath.attractorTo,\n        },\n        to: { x: null, y: null },\n        attractorTo: null,\n        isFromValidated: false,\n      },\n    };\n  } else {\n    return state;\n  }\n};\n\nexport const savePathElement = (state, action) => {\n  const attractorTo = state.currentMagnet.attractor && {\n    ...state.currentMagnet.attractor,\n  };\n  const { attractorFrom, from, to, elementType } = state.newPath;\n\n  const newId_element = uuid();\n\n  const fromAnchor =\n    attractorFrom && attractorFrom.type === \"ANCHOR\"\n      ? attractorFrom.id\n      : uuid();\n  const toAnchor =\n    attractorTo && attractorTo.type === \"ANCHOR\" ? attractorTo.id : uuid();\n\n  // create anchors if necessary\n  let newAnchors = { ...state.anchors };\n  if (!attractorFrom || attractorFrom.type !== \"ANCHOR\") {\n    newAnchors = {\n      byId: {\n        ...newAnchors.byId,\n        [fromAnchor]: {\n          id: fromAnchor,\n          x: from.x,\n          y: from.y,\n        },\n      },\n      allIds: [...newAnchors.allIds, fromAnchor],\n    };\n  }\n  if (!attractorTo || attractorTo.type !== \"ANCHOR\") {\n    newAnchors = {\n      byId: {\n        ...newAnchors.byId,\n        [toAnchor]: {\n          id: toAnchor,\n          x: to.x,\n          y: to.y,\n        },\n      },\n      allIds: [...newAnchors.allIds, toAnchor],\n    };\n  }\n\n  // create weak links if necessary\n  const newWeakLinks = [];\n  if (attractorFrom && attractorFrom.type === \"NODE\") {\n    newWeakLinks.push({\n      anchorId: fromAnchor,\n      nodeId: attractorFrom.id,\n      name: attractorFrom.name,\n    });\n  }\n  if (attractorTo && attractorTo.type === \"NODE\") {\n    newWeakLinks.push({\n      anchorId: toAnchor,\n      nodeId: attractorTo.id,\n      name: attractorTo.name,\n    });\n  }\n\n  return {\n    ...state,\n    newPath: {\n      ...state.newPath,\n      isFromValidated: false,\n      from: {\n        ...to,\n      },\n      attractorFrom: attractorTo && { ...attractorTo },\n      to: {\n        x: null,\n        y: null,\n      },\n    },\n    pathComponents: {\n      byId: {\n        ...state.pathComponents.byId,\n        [newId_element]: {\n          id: newId_element,\n          from: fromAnchor,\n          to: toAnchor,\n          type: elementType,\n          currant: defaultCurrant,\n          label: \"\",\n          annotation: \"\",\n          mirror: false,\n          invert: false,\n        },\n      },\n      allIds: [...state.pathComponents.allIds, newId_element],\n    },\n    anchors: { ...newAnchors },\n    weakLinks: [...state.weakLinks, ...newWeakLinks],\n  };\n};\n\nexport const updatePosition = (state, action) => {\n  const { x, y, shiftPress } = action;\n\n  if (state.newPath.isFromValidated) {\n    if (shiftPress) {\n      const { x: xFrom, y: yFrom } = state.newPath.from;\n      if (Math.abs(x - xFrom) > Math.abs(y - yFrom)) {\n        return {\n          ...state,\n          newPath: {\n            ...state.newPath,\n            to: { x: x, y: yFrom },\n            movedAfterFromCreation: true,\n          },\n        };\n      } else {\n        return {\n          ...state,\n          newPath: {\n            ...state.newPath,\n            to: { x: xFrom, y: y },\n            movedAfterFromCreation: true,\n          },\n        };\n      }\n    }\n    return {\n      ...state,\n      newPath: {\n        ...state.newPath,\n        to: { x: x, y: y },\n        movedAfterFromCreation: true,\n      },\n    };\n  } else {\n    return {\n      ...state,\n      newPath: {\n        ...state.newPath,\n        from: { x: x, y: y },\n      },\n    };\n  }\n};\n","import { isInRectangle } from \"./utils\";\n\nimport { MODE_SELECT, MODE_RECTANGLE_SELECTION } from \"./interactionModes\";\n\nexport const updatePosition = (state, action) => {\n  const { x, y } = action;\n  const newRectangle = {\n    ...state.rectangleSelection,\n    x1: x,\n    y1: y,\n  };\n\n  return {\n    ...state,\n    selection: [\n      ...state.anchors.allIds.filter((id) =>\n        isInRectangle(state.anchors.byId[id], newRectangle)\n      ),\n    ],\n    rectangleSelection: {\n      ...state.rectangleSelection,\n      x1: x,\n      y1: y,\n    },\n  };\n};\n\nexport const stopRectangleSelection = (state, action) => {\n  // add equality verification, if rectangle has no area it's probably a single click\n  // so we reset the selection\n  return {\n    ...state,\n    mode: MODE_SELECT,\n    rectangleSelection: {},\n    selection:\n      state.rectangleSelection.x0 === state.rectangleSelection.x1 ||\n      state.rectangleSelection.y0 === state.rectangleSelection.y1\n        ? []\n        : [...state.selection],\n  };\n};\n\nexport const startRectangleSelection = (state, action) => {\n  return {\n    ...state,\n    mode: MODE_RECTANGLE_SELECTION,\n    rectangleSelection: {\n      x0: action.x,\n      y0: action.y,\n      x1: action.x,\n      y1: action.y,\n    },\n  };\n};\n","import { MODE_CREATE_NODE_ELEMENT } from \"./interactionModes\";\n\nimport { getAdhesivePoints, isAnchor } from \"./utils\";\n\nimport { v4 as uuid } from \"uuid\";\n\nexport const updatePosition = (state, action) => {\n  const { x, y } = action;\n  return {\n    ...state,\n    newNode: {\n      ...state.newNode,\n      position: { x: x, y: y },\n    },\n  };\n};\n\nexport const startNodeCreation = (state, action) => {\n  return {\n    ...state,\n    selection: [],\n    adhesivePoints: [...getAdhesivePoints(action.elementType)],\n    mode: MODE_CREATE_NODE_ELEMENT,\n    newNode: {\n      elementType: action.elementType,\n      position: { x: null, y: null },\n    },\n  };\n};\n\nexport const saveNodeCreation = (state, action) => {\n  if (\n    state.mode === MODE_CREATE_NODE_ELEMENT &&\n    state.newNode.position.x !== null &&\n    state.newNode.position.y !== null\n  ) {\n    const newId_element = uuid();\n    const positionId = uuid();\n\n    const newWeakLink = [];\n\n    if (state.currentMagnet.attractor && state.currentMagnet.attracted) {\n      // node created relatively to an anchor\n      // We will link this anchor to the new node\n      if (state.currentMagnet.attractor.type === \"ANCHOR\") {\n        newWeakLink.push({\n          anchorId: state.currentMagnet.attractor.id,\n          nodeId: newId_element,\n          name: state.currentMagnet.attracted.name,\n        });\n      }\n      if (state.currentMagnet.attractor.type === \"NODE\") {\n        newWeakLink.push({\n          anchorId: positionId,\n          nodeId: state.currentMagnet.attractor.id,\n          name: state.currentMagnet.attractor.name,\n          nameAnchor: state.currentMagnet.attracted.name,\n        });\n      }\n    }\n\n    return {\n      ...state,\n      newNode: {\n        ...state.newNode,\n        position: { x: null, y: null },\n      },\n      pathComponents: {\n        byId: {\n          ...state.pathComponents.byId,\n          [newId_element]: {\n            id: newId_element,\n            position: positionId,\n            type: state.newNode.elementType,\n          },\n        },\n        allIds: [...state.pathComponents.allIds, newId_element],\n      },\n      anchors: {\n        ...state.anchors,\n        byId: {\n          ...state.anchors.byId,\n          [positionId]: {\n            id: positionId,\n            x: state.newNode.position.x,\n            y: state.newNode.position.y,\n            isNodePosition: true,\n            nodeId: newId_element,\n          },\n        },\n      },\n      weakLinks: [...state.weakLinks, ...newWeakLink],\n    };\n  }\n  return state;\n};\n","import { componentUseThisAnchor, replaceComponentAnchor } from \"./utils\";\n\nimport { v4 as uuid } from \"uuid\";\n\nexport const stackAnchors = (state, action) => {\n  const anchorsSelected = state.selection.filter(\n    (id) => id in state.anchors.byId\n  );\n  const movedAnchors = [];\n  if (\n    anchorsSelected.length <= 1 ||\n    ![\"U\", \"D\", \"L\", \"R\"].includes(action.direction)\n  ) {\n    return state;\n  } else {\n    const newPosition = {};\n\n    anchorsSelected.forEach((id, index) => {\n      const anchor = state.anchors.byId[id];\n\n      switch (action.direction) {\n        case \"U\":\n          newPosition.y =\n            index === 0 ? anchor.y : Math.min(newPosition.y, anchor.y);\n          break;\n        case \"D\":\n          newPosition.y =\n            index === 0 ? anchor.y : Math.max(newPosition.y, anchor.y);\n          break;\n        case \"L\":\n          newPosition.x =\n            index === 0 ? anchor.x : Math.min(newPosition.x, anchor.x);\n          break;\n        case \"R\":\n          newPosition.x =\n            index === 0 ? anchor.x : Math.max(newPosition.x, anchor.x);\n          break;\n        default:\n          break;\n      }\n      if (\n        (newPosition.x && newPosition.x !== anchor.x) ||\n        (newPosition.y && newPosition.y !== anchor.y)\n      ) {\n        movedAnchors.push(id);\n      }\n    });\n\n    anchorsSelected.forEach((id) => {\n      state.anchors.byId[id] = {\n        ...state.anchors.byId[id],\n        ...newPosition,\n      };\n    });\n    return {\n      ...state,\n      anchors: {\n        byId: { ...state.anchors.byId },\n        allIds: state.anchors.allIds,\n      },\n      weakLinks: [\n        ...state.weakLinks.filter(\n          ({ anchorId }) => !movedAnchors.includes(anchorId)\n        ),\n      ],\n    };\n  }\n};\n\nexport const splitAnchor = (state, action) => {\n  let anchorId = action.anchorId;\n  if (\n    !anchorId &&\n    state.selection.length === 1 &&\n    state.anchors.allIds.includes(state.selection[0])\n  ) {\n    anchorId = state.selection[0];\n  }\n  if (anchorId && state.anchors.allIds.includes(anchorId)) {\n    const componentsToChange = state.pathComponents.allIds.filter((id) =>\n      componentUseThisAnchor(state.pathComponents.byId[id], anchorId)\n    );\n    if (componentsToChange.length <= 1) {\n      return state;\n    }\n\n    const newAnchors = state.anchors;\n    const newComponents = state.pathComponents.byId;\n    const newWeakLinks = [];\n    const weakLinksToCopy = state.weakLinks.filter(\n      ({ anchorId: linkedAnchorId }) => anchorId === linkedAnchorId\n    );\n\n    componentsToChange.slice(1).forEach((componentId) => {\n      const newAnchorId = uuid();\n\n      newComponents[componentId] = replaceComponentAnchor(\n        state.pathComponents.byId[componentId],\n        anchorId,\n        newAnchorId\n      );\n\n      newAnchors.allIds = [newAnchorId, ...newAnchors.allIds];\n      newAnchors.byId = {\n        ...newAnchors.byId,\n        [newAnchorId]: { ...newAnchors.byId[anchorId] },\n      };\n\n      weakLinksToCopy.forEach((linkToCopy) => {\n        newWeakLinks.push({ ...linkToCopy, anchorId: newAnchorId });\n      });\n    });\n\n    return {\n      ...state,\n      pathComponents: {\n        ...state.pathComponents,\n        byId: { ...newComponents },\n      },\n      anchors: {\n        allIds: [...newAnchors.allIds],\n        byId: { ...newAnchors.byId },\n      },\n      weakLinks: [...state.weakLinks, ...newWeakLinks],\n    };\n  }\n  return state;\n};\n","import { createStore } from \"redux\";\nimport {\n  START_DRAGGING,\n  START_SELECT,\n  TOGGLE_SELECTION,\n  STOP_DRAGGING,\n  START_CREATE_PATH_ELEMENT,\n  START_CREATE_NODE_ELEMENT,\n  ELEMENT_CREATION_NEXT_STEP,\n  VALIDATE_FIRST_STEP_PATH_ELEMENT_CREATION,\n  INVALIDATE_FIRST_STEP_PATH_ELEMENT_CREATION,\n  SAVE_PATH_ELEMENT_CREATION,\n  UPDATE_POSITION,\n  SPLIT_ANCHOR,\n  START_RECTANGLE_SELECTION,\n  STOP_RECTANGLE_SELECTION,\n  STACK_SELECTED_ANCHORS,\n  DELETE_ELEMENT,\n  UPDATE_COMPONENT,\n} from \"../actions\";\n\nimport {\n  MODE_SELECT,\n  MODE_DRAG,\n  MODE_CREATE_PATH_ELEMENT,\n  MODE_CREATE_NODE_ELEMENT,\n  MODE_RECTANGLE_SELECTION,\n} from \"./interactionModes\";\n\nimport { initial_state } from \"./debugInitialState\";\n\nimport {\n  startDragging,\n  stopDragging,\n  updatePosition as draggingUpdatePosition,\n} from \"./dragging\";\n\nimport deleteElement from \"./delete\";\nimport {\n  startCreatePathElement,\n  validateFirstStepPathElement,\n  invalidateFirstStepPathElement,\n  savePathElement,\n  updatePosition as pathCreationUpdatePosition,\n} from \"./pathCreation\";\n\nimport {\n  stopRectangleSelection,\n  startRectangleSelection,\n  updatePosition as rectangleSelectionUpdatePosition,\n} from \"./rectangleSelection\";\n\nimport {\n  startNodeCreation,\n  saveNodeCreation,\n  updatePosition as nodeCreationUpdatePosition,\n} from \"./nodeCreation\";\n\nimport { stackAnchors, splitAnchor } from \"./anchorHelper\";\n\nfunction update(state = initial_state, action) {\n  switch (action.type) {\n    case UPDATE_COMPONENT:\n      const { id, name, value } = action;\n\n      return {\n        ...state,\n        pathComponents: {\n          ...state.pathComponents,\n          byId: {\n            ...state.pathComponents.byId,\n            [id]: {\n              ...state.pathComponents.byId[id],\n              [name]: value,\n            },\n          },\n        },\n      };\n    case TOGGLE_SELECTION:\n      if (action.reset) {\n        return {\n          ...state,\n          selection: [action.objectId],\n        };\n      } else {\n        const index = state.selection.findIndex((x) => x === action.objectId);\n        if (index >= 0) {\n          return {\n            ...state,\n            selection: [\n              ...state.selection.slice(0, index),\n              ...state.selection.slice(index + 1),\n            ],\n          };\n        } else {\n          return {\n            ...state,\n            selection: [...state.selection, action.objectId],\n          };\n        }\n      }\n    case START_SELECT:\n      return {\n        ...state,\n        selection: [],\n        adhesivePoints: [],\n        mode: MODE_SELECT,\n      };\n\n    case START_DRAGGING:\n      return startDragging(state, action);\n\n    case STOP_DRAGGING:\n      return stopDragging(state, action);\n\n    case UPDATE_POSITION:\n      const { attractor, attracted } = action;\n      switch (state.mode) {\n        case MODE_DRAG:\n          return {\n            ...draggingUpdatePosition(state, action),\n            currentMagnet: { attractor, attracted },\n          };\n\n        case MODE_CREATE_PATH_ELEMENT:\n          return {\n            ...pathCreationUpdatePosition(state, action),\n            currentMagnet: { attractor, attracted },\n          };\n\n        case MODE_CREATE_NODE_ELEMENT:\n          return {\n            ...nodeCreationUpdatePosition(state, action),\n            currentMagnet: { attractor, attracted },\n          };\n\n        case MODE_RECTANGLE_SELECTION:\n          return {\n            ...rectangleSelectionUpdatePosition(state, action),\n            currentMagnet: { attractor, attracted },\n          };\n\n        default:\n          return {\n            ...state,\n            currentMagnet: { attractor, attracted },\n          };\n      }\n\n    case START_CREATE_PATH_ELEMENT:\n      return startCreatePathElement(state, action);\n\n    case START_CREATE_NODE_ELEMENT:\n      return startNodeCreation(state, action);\n\n    case ELEMENT_CREATION_NEXT_STEP:\n      return saveNodeCreation(state, action);\n\n    case VALIDATE_FIRST_STEP_PATH_ELEMENT_CREATION:\n      return validateFirstStepPathElement(state, action);\n\n    case INVALIDATE_FIRST_STEP_PATH_ELEMENT_CREATION:\n      return invalidateFirstStepPathElement(state, action);\n\n    case SAVE_PATH_ELEMENT_CREATION:\n      return savePathElement(state, action);\n\n    case SPLIT_ANCHOR:\n      return splitAnchor(state, action);\n\n    case START_RECTANGLE_SELECTION:\n      return startRectangleSelection(state, action);\n\n    case STOP_RECTANGLE_SELECTION:\n      return stopRectangleSelection(state, action);\n\n    case STACK_SELECTED_ANCHORS:\n      return stackAnchors(state, action);\n\n    case DELETE_ELEMENT:\n      return deleteElement(state, action);\n\n    default:\n      return state;\n  }\n}\n\n// Create a Redux store holding the state of your app.\n// Its API is { subscribe, dispatch, getState }.\nlet store = createStore(update);\n\nexport default store;\n","import React from \"react\";\nimport components from \"../components\";\nimport { connect } from \"react-redux\";\nimport { MODE_SELECT } from \"../redux/store/interactionModes\";\nimport { toggleSelection, startDragging } from \"../redux/actions\";\n\nconst mapDispatchToProps = (dispatch, { svgRef }) => {\n  return {\n    toggleSelection: (objectId, reset) =>\n      dispatch(toggleSelection(objectId, reset)),\n    startDragging: (x, y) => {\n      const { x: xOffset, y: yOffset } = svgRef.current.getBoundingClientRect();\n      dispatch(startDragging(x - xOffset, y - yOffset));\n    },\n  };\n};\nconst mapStateToProps = (state) => {\n  return {\n    pathComponents: state.pathComponents,\n    selection: state.selection,\n    mode: state.mode,\n  };\n};\n\nconst Components = ({\n  pathComponents,\n  selection,\n  mode,\n  startDragging,\n  toggleSelection,\n}) => (\n  <>\n    {pathComponents.allIds.map(\n      (id) =>\n        pathComponents.byId[id].type &&\n        components[pathComponents.byId[id].type]({\n          ...pathComponents.byId[id],\n          onMouseDown:\n            mode === MODE_SELECT\n              ? (event) => {\n                  event.stopPropagation();\n                  if (\n                    !event.ctrlKey &&\n                    selection.includes(pathComponents.byId[id].id)\n                  ) {\n                    startDragging(\n                      event.nativeEvent.clientX,\n                      event.nativeEvent.clientY\n                    );\n                  } else {\n                    toggleSelection(pathComponents.byId[id].id, !event.ctrlKey);\n                  }\n                }\n              : null,\n          selected: selection.includes(pathComponents.byId[id].id),\n          // showHandles: mode === MODE_LINK,\n        })\n    )}\n  </>\n);\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Components);\n","import React from \"react\";\n\nimport \"./style.scss\";\nimport { connect } from \"react-redux\";\nimport { MODE_SELECT } from \"../redux/store/interactionModes\";\nimport { toggleSelection, startDragging } from \"../redux/actions\";\n\nconst mapDispatchToProps = (dispatch, { svgRef }) => {\n  return {\n    toggleSelection: (objectId, reset) =>\n      dispatch(toggleSelection(objectId, reset)),\n    startDragging: (x, y) => {\n      const { x: xOffset, y: yOffset } = svgRef.current.getBoundingClientRect();\n      dispatch(startDragging(x - xOffset, y - yOffset));\n    },\n  };\n};\nconst mapStateToProps = (state, { id }) => {\n  return {\n    x: state.anchors.byId[id].x,\n    y: state.anchors.byId[id].y,\n    mode: state.mode,\n    selected: state.selection.includes(id),\n  };\n};\n\nconst Anchor = ({\n  id,\n  x,\n  y,\n  mode,\n  selected,\n  startDragging,\n  toggleSelection,\n}) => (\n  <circle\n    cx={x}\n    cy={y}\n    r={5}\n    className={`anchor ${selected ? \"selected\" : \"\"}`}\n    onMouseDown={\n      mode === MODE_SELECT\n        ? (event) => {\n            event.stopPropagation();\n            if (!event.ctrlKey && selected) {\n              startDragging(\n                event.nativeEvent.clientX,\n                event.nativeEvent.clientY\n              );\n            } else {\n              toggleSelection(id, !event.ctrlKey);\n            }\n          }\n        : null\n    }\n  />\n);\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Anchor);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\n\nimport Anchor from \"../atoms/anchor\";\n\nconst mapStateToProps = (state) => {\n  return {\n    anchorIds: state.anchors.allIds,\n  };\n};\n\nconst Anchors = ({ anchorIds, svgRef }) => (\n  <>\n    {anchorIds.map((id) => (\n      <Anchor key={id} id={id} svgRef={svgRef} />\n    ))}\n  </>\n);\n\nexport default connect(mapStateToProps)(Anchors);\n","import React, { useState } from \"react\";\nimport { connect } from \"react-redux\";\n\nimport { updatePosition, stopDragging } from \"../redux/actions\";\nimport { MODE_DRAG } from \"../redux/store/interactionModes\";\nconst mapDispatchToProps = (dispatch, { attractor, attracted }) => {\n  return {\n    updatePosition: (x, y) =>\n      dispatch(updatePosition({ x, y, attractor, attracted })),\n    stopDragging: () => dispatch(stopDragging()),\n  };\n};\n\nconst Magnet = ({\n  id,\n  x,\n  y,\n  dx,\n  dy,\n  color,\n  mode,\n  updatePosition,\n  stopDragging,\n}) => {\n  const [isUsed, setIsUsed] = useState(false);\n\n  return (\n    <>\n      {isUsed && (\n        <circle\n          cx={x}\n          cy={y}\n          r={5}\n          style={{\n            fill: \"none\",\n            stroke: \"red\",\n            strokeWidth: 2,\n          }}\n        />\n      )}\n      <circle\n        cx={x + dx}\n        cy={y + dy}\n        r={10}\n        style={{\n          fill: color || \"transparent\",\n        }}\n        onMouseEnter={(event) => {\n          event.stopPropagation();\n          updatePosition(x + dx, y + dy);\n          setIsUsed(true);\n        }}\n        onMouseLeave={() => setIsUsed(false)}\n        onMouseMove={\n          (event) => event.stopPropagation() //stop the propagation\n        }\n        onMouseUp={\n          mode === MODE_DRAG\n            ? (event) => {\n                event.stopPropagation();\n                stopDragging();\n              }\n            : null\n        }\n      />\n    </>\n  );\n};\n\nexport default connect(null, mapDispatchToProps)(Magnet);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\n\nimport {\n  MODE_CREATE_PATH_ELEMENT,\n  MODE_CREATE_NODE_ELEMENT,\n  MODE_DRAG,\n} from \"../redux/store/interactionModes\";\n\nimport Magnet from \"../atoms/magnet\";\nimport { getElementAnchors } from \"../components\";\n\nconst mapStateToProps = (state) => {\n  return {\n    anchors: state.anchors,\n    pathComponents: state.pathComponents,\n    mode: state.mode,\n    anchorsToMove: state.anchorsToMove,\n    selection: state.selection,\n    adhesivePoints: state.adhesivePoints || null,\n  };\n};\n\nconst isMoving = (element, anchorsToMove) => {\n  // help function to filter magnets\n  if (!anchorsToMove) {\n    return false;\n  }\n  if (typeof element == \"string\" && anchorsToMove.includes(element)) {\n    return true;\n  }\n  if (element.from && anchorsToMove.includes(element.from)) {\n    return true;\n  }\n  if (element.to && anchorsToMove.includes(element.to)) {\n    return true;\n  }\n  if (element.position && anchorsToMove.includes(element.position)) {\n    return true;\n  }\n  return false;\n};\n\nconst Magnets = ({\n  mode,\n  anchors,\n  pathComponents,\n  anchorsToMove,\n  adhesivePoints,\n}) => {\n  if (\n    mode !== MODE_DRAG &&\n    mode !== MODE_CREATE_NODE_ELEMENT &&\n    mode !== MODE_CREATE_PATH_ELEMENT\n  ) {\n    return null;\n  }\n\n  return (\n    <>\n      {pathComponents.allIds\n        .filter((id) => !isMoving(pathComponents.byId[id], anchorsToMove))\n        .reduce(\n          (accumulator, id) => [\n            ...accumulator,\n            ...getElementAnchors({\n              ...pathComponents.byId[id],\n              fromCoords:\n                pathComponents.byId[id].from &&\n                anchors.byId[pathComponents.byId[id].from],\n              toCoords:\n                pathComponents.byId[id].to &&\n                anchors.byId[pathComponents.byId[id].to],\n              positionCoords:\n                pathComponents.byId[id].position &&\n                anchors.byId[pathComponents.byId[id].position],\n            }).map(({ x, y, name }) =>\n              adhesivePoints.reduce(\n                (\n                  accu,\n                  { type, dx, dy, name: nameAdhesive = \"\", id: idAdhesive }\n                ) => {\n                  return [\n                    ...accu,\n                    <Magnet\n                      key={`${id}-${name}<-${idAdhesive}-${nameAdhesive || \"\"}`}\n                      x={x}\n                      dx={dx}\n                      y={y}\n                      dy={dy}\n                      mode={mode}\n                      attractor={{\n                        type: pathComponents.byId[id].position\n                          ? \"NODE\"\n                          : \"PATH\",\n                        name: name,\n                        id: id,\n                      }}\n                      attracted={{\n                        type: type,\n                        name: nameAdhesive,\n                        id: idAdhesive,\n                      }}\n                    />,\n                  ];\n                },\n                []\n              )\n            ),\n          ],\n          []\n        )}\n      {anchors.allIds\n        .filter((id) => !isMoving(id, anchorsToMove))\n        .map((id) =>\n          adhesivePoints.reduce(\n            (\n              accu,\n              { type, dx, dy, name: nameAdhesive = \"\", id: idAdhesive }\n            ) => {\n              return [\n                ...accu,\n                <Magnet\n                  key={`${id}<-${idAdhesive}-${nameAdhesive || \"\"}`}\n                  x={anchors.byId[id].x}\n                  dx={dx}\n                  y={anchors.byId[id].y}\n                  dy={dy}\n                  mode={mode}\n                  attractor={{ type: \"ANCHOR\", name: \"\", id: id }}\n                  attracted={{\n                    type: type,\n                    name: nameAdhesive,\n                    id: idAdhesive,\n                  }}\n                />,\n              ];\n            },\n            []\n          )\n        )}\n    </>\n  );\n};\n\nexport default connect(mapStateToProps)(Magnets);\n","import React, { useRef, useState } from \"react\";\nimport { connect } from \"react-redux\";\nimport components from \"../components\";\nimport {\n  updatePosition,\n  stopDragging,\n  validateFirstStepPathElementCreation,\n  invalidateFirstStepPathElementCreation,\n  savePathElementCreation,\n  nextStepOfElementCreation,\n  startRectangleSelection,\n  stopRectangleSelection,\n} from \"../redux/actions\";\nimport {\n  MODE_DRAG,\n  MODE_CREATE_PATH_ELEMENT,\n  MODE_CREATE_NODE_ELEMENT,\n  MODE_SELECT,\n  MODE_RECTANGLE_SELECTION,\n} from \"../redux/store/interactionModes\";\n\nimport Components from \"./components\";\nimport Anchors from \"./anchors\";\nimport Magnets from \"./magnets\";\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    updatePosition: (x, y, shiftPress) =>\n      dispatch(updatePosition({ x, y, shiftPress })),\n    stopDragging: () => dispatch(stopDragging()),\n    validateFirstStepPathElementCreation: () =>\n      dispatch(validateFirstStepPathElementCreation()),\n    invalidateFirstStepPathElementCreation: () =>\n      dispatch(invalidateFirstStepPathElementCreation()),\n    savePathElementCreation: () => dispatch(savePathElementCreation()),\n    nextStepOfElementCreation: () => dispatch(nextStepOfElementCreation()),\n    startRectangleSelection: (x, y) => dispatch(startRectangleSelection(x, y)),\n    stopRectangleSelection: () => dispatch(stopRectangleSelection()),\n  };\n};\nconst mapStateToProps = (state) => {\n  return {\n    mode: state.mode,\n    newPath: state.newPath,\n    newNode: state.newNode,\n    rectangleSelection: state.rectangleSelection,\n  };\n};\n\nconst Container = ({\n  mode,\n  newPath,\n  newNode,\n  rectangleSelection,\n  stopDragging,\n  updatePosition,\n  validateFirstStepPathElementCreation,\n  invalidateFirstStepPathElementCreation,\n  savePathElementCreation,\n  nextStepOfElementCreation,\n  startRectangleSelection,\n  stopRectangleSelection,\n}) => {\n  const svgRef = useRef();\n\n  const followMouse = (event) => {\n    const { x: xOffset, y: yOffset } = svgRef.current.getBoundingClientRect();\n\n    switch (mode) {\n      case MODE_DRAG:\n      case MODE_CREATE_PATH_ELEMENT:\n      case MODE_CREATE_NODE_ELEMENT:\n      case MODE_RECTANGLE_SELECTION:\n        updatePosition(\n          event.nativeEvent.clientX - xOffset,\n          event.nativeEvent.clientY - yOffset,\n          event.shiftKey\n        );\n        break;\n      default:\n        break;\n    }\n  };\n\n  const click = (event) => {\n    const { x: xOffset, y: yOffset } = svgRef.current.getBoundingClientRect();\n\n    switch (mode) {\n      case MODE_SELECT:\n        event.stopPropagation();\n        startRectangleSelection(\n          event.nativeEvent.clientX - xOffset,\n          event.nativeEvent.clientY - yOffset\n        );\n        break;\n      case MODE_CREATE_PATH_ELEMENT:\n        event.stopPropagation();\n        if (newPath.isFromValidated) {\n          savePathElementCreation(\n            event.nativeEvent.clientX - xOffset,\n            event.nativeEvent.clientY - yOffset\n          );\n        } else {\n          validateFirstStepPathElementCreation();\n        }\n        break;\n      case MODE_CREATE_NODE_ELEMENT:\n        event.stopPropagation();\n        nextStepOfElementCreation();\n        break;\n      default:\n        break;\n    }\n  };\n\n  return (\n    <>\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        viewBox=\"0 0 1000 600\"\n        style={{ width: 1000, height: 600, background: \"lightgray\" }}\n        onMouseMove={\n          mode === MODE_DRAG ||\n          mode === MODE_CREATE_PATH_ELEMENT ||\n          mode === MODE_CREATE_NODE_ELEMENT ||\n          mode === MODE_RECTANGLE_SELECTION\n            ? followMouse\n            : null\n        }\n        onMouseDown={click}\n        onMouseUp={\n          mode === MODE_DRAG\n            ? () => stopDragging()\n            : mode === MODE_RECTANGLE_SELECTION\n            ? (event) => {\n                event.stopPropagation();\n                stopRectangleSelection();\n              }\n            : null\n        }\n        ref={svgRef}\n      >\n        <Components svgRef={svgRef} />\n\n        {/* display the path element in during its creation */}\n\n        {mode === MODE_CREATE_PATH_ELEMENT && // the element\n          newPath &&\n          newPath.isFromValidated &&\n          newPath.to &&\n          newPath.to.x !== null &&\n          newPath.to.y !== null &&\n          newPath.from &&\n          newPath.from.x !== null &&\n          newPath.from.y !== null &&\n          components[newPath.elementType]({\n            fromCoords: newPath.from,\n            toCoords: newPath.to,\n          })}\n        {mode === MODE_CREATE_PATH_ELEMENT && //the anchor TO\n          newPath &&\n          newPath.isFromValidated &&\n          newPath.to.x !== null &&\n          newPath.to.y !== null && (\n            <circle cx={newPath.to.x} cy={newPath.to.y} r={5} />\n          )}\n        {mode === MODE_CREATE_PATH_ELEMENT && // the anchor FROM\n          newPath &&\n          newPath.from &&\n          newPath.from.x !== null &&\n          newPath.from.y !== null && (\n            <circle\n              cx={newPath.from.x}\n              cy={newPath.from.y}\n              r={5}\n              onMouseEnter={invalidateFirstStepPathElementCreation}\n            />\n          )}\n\n        {/* display the path element in during its creation */}\n\n        {mode === MODE_CREATE_NODE_ELEMENT && // the element\n          newNode &&\n          newNode.position &&\n          newNode.position.x !== null &&\n          newNode.position.y !== null &&\n          components[newNode.elementType]({\n            positionCoords: newNode.position,\n          })}\n        {mode === MODE_CREATE_NODE_ELEMENT && // the anchor POSITION\n          newNode &&\n          newNode.position &&\n          newNode.position.x !== null &&\n          newNode.position.y !== null && (\n            <circle cx={newNode.position.x} cy={newNode.position.y} r={5} />\n          )}\n\n        <Anchors svgRef={svgRef} />\n        <Magnets svgRef={svgRef} />\n\n        {mode === MODE_RECTANGLE_SELECTION && (\n          <path\n            d={`M ${rectangleSelection.x0} ${rectangleSelection.y0} L  ${rectangleSelection.x0} ${rectangleSelection.y1} L ${rectangleSelection.x1} ${rectangleSelection.y1} L  ${rectangleSelection.x1} ${rectangleSelection.y0} Z`}\n            style={{ fill: \"transparent\", stroke: \"red\", strokeWidth: 1 }}\n          />\n        )}\n      </svg>\n    </>\n  );\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Container);\n","import { drawElement, isMultyPole, isPath } from \"../../components\";\nimport { MULTIPLICATIVE_CONST, R_LEN } from \"../../components/constantes\";\n\nconst isNode = (element) => !!element.position;\n\nconst getCoordId = ({ x, y }) =>\n  `${typeof x === \"number\" ? x.toFixed(2) : x}-${\n    typeof y === \"number\" ? y.toFixed(2) : y\n  }`;\n\nconst getCoord = (x, y, coords) => {\n  const coordId = getCoordId({ x: x, y: y });\n\n  if (coords[coordId].name) {\n    return `(${coords[coordId].name})`;\n  } else {\n    return `(${((x / MULTIPLICATIVE_CONST) * R_LEN).toFixed(2)}, ${(\n      (-y / MULTIPLICATIVE_CONST) *\n      R_LEN\n    ).toFixed(2)})`;\n  }\n};\n\nconst removeDrawnElements = (drawnElements) => (listeOfId) =>\n  listeOfId.filter((id) => !drawnElements[id]);\n\nconst compareCoord = (drawnElements, coords) => (coordId1, coordId2) => {\n  const { endingPaths: endingPaths1, nodeAssociated: nodeAssociated1 } = coords[\n    coordId1\n  ];\n  const { endingPaths: endingPaths2, nodeAssociated: nodeAssociated2 } = coords[\n    coordId2\n  ];\n\n  if (\n    removeDrawnElements(drawnElements)(nodeAssociated1).length >\n    removeDrawnElements(drawnElements)(nodeAssociated2).length\n  ) {\n    return -1;\n  }\n  if (\n    removeDrawnElements(drawnElements)(nodeAssociated1).length <\n    removeDrawnElements(drawnElements)(nodeAssociated2).length\n  ) {\n    return 1;\n  }\n  if (\n    removeDrawnElements(drawnElements)(endingPaths1).length <\n    removeDrawnElements(drawnElements)(endingPaths2).length\n  ) {\n    return -1;\n  }\n  if (\n    removeDrawnElements(drawnElements)(endingPaths1).length >\n    removeDrawnElements(drawnElements)(endingPaths2).length\n  ) {\n    return 1;\n  }\n  return 0;\n};\n\nconst drawPathFromCoord = (\n  startCoordId,\n  coords,\n  state,\n  drawnElements,\n  nbOfCoordinateUsed\n) => {\n  const elementsToAdd = [];\n\n  let nbOfCreatedNames = 0;\n  let nextName = `point${nbOfCoordinateUsed + 1}`;\n  let currantCoordId = startCoordId;\n  let currantCoord = coords[currantCoordId];\n\n  let nextPaths = currantCoord.startingPaths.filter((id) => !drawnElements[id]); //only path elements starting here not already drawn\n  let arrivingPaths = currantCoord.endingPaths.filter(\n    (id) => !drawnElements[id]\n  );\n  let nextNode = currantCoord.nodeAssociated.filter((id) => {\n    if (drawnElements[id]) {\n      return false;\n    }\n    const type = state.pathComponents.byId[id].type;\n    return !isMultyPole[type];\n  }); //only nodes : not already drawn and monopole\n\n  let coordIsNew = true;\n  while (nextPaths.length > 0 || nextNode.length > 0) {\n    // add draw if it's the beginning\n    if (elementsToAdd.length === 0) {\n      elementsToAdd.push(`\\\\draw `);\n    }\n\n    // add the coordinate if needed\n    if (coordIsNew) {\n      elementsToAdd.push(\n        `${getCoord(currantCoord.x, currantCoord.y, coords)} `\n      );\n      if (\n        !currantCoord.name &&\n        (nextPaths.length > 1 || arrivingPaths.length > 0)\n      ) {\n        //save name\n        elementsToAdd.push(`coordinate(${nextName}) `);\n        coords[currantCoordId].name = nextName;\n\n        //get ready for next name\n        nbOfCreatedNames += 1;\n        nextName = `point${nbOfCoordinateUsed + nbOfCreatedNames + 1}`;\n      }\n    }\n\n    if (nextNode.length > 0) {\n      // create a node if possible\n      coordIsNew = false;\n      const nodeId = nextNode.pop();\n      const element = state.pathComponents.byId[nodeId];\n\n      elementsToAdd.push(`${drawElement(element)} `);\n      drawnElements[element.id] = true;\n    } else {\n      // create path otherwise\n      coordIsNew = true;\n      const element = state.pathComponents.byId[nextPaths[0]];\n      elementsToAdd.push(drawElement(element));\n      drawnElements[element.id] = true;\n\n      // get information of the next coordinate\n      currantCoordId = getCoordId(state.anchors.byId[element.to]);\n      currantCoord = coords[currantCoordId];\n      nextPaths = currantCoord.startingPaths.filter((id) => !drawnElements[id]); //only path elements starting here not already drawn\n      arrivingPaths = currantCoord.endingPaths.filter(\n        (id) => !drawnElements[id]\n      );\n      nextNode = currantCoord.nodeAssociated.filter((id) => {\n        if (drawnElements[id]) {\n          return false;\n        }\n        const type = state.pathComponents.byId[id].type;\n        return !isMultyPole[type];\n      });\n    }\n  }\n\n  if (elementsToAdd.length > 0) {\n    //check that we drw something\n\n    elementsToAdd.push(`${getCoord(currantCoord.x, currantCoord.y, coords)} `);\n    if (!currantCoord.name && arrivingPaths.length > 0) {\n      //if we will use this coord in the future so we give it a name\n      coords[currantCoordId].name = nextName;\n      elementsToAdd.push(`coordinate(${nextName}) `);\n      nbOfCreatedNames += 1;\n      nextName = `point${nbOfCoordinateUsed + nbOfCreatedNames + 1}`;\n    }\n    elementsToAdd.push(\";\");\n  }\n  return [elementsToAdd, nbOfCreatedNames];\n};\n\nconst initilizeCoords = (state) => {\n  // coords = {[(x, y)]: {\n  // name:null||str,\n  // pathAssociated :\n  //     {\n  //       [id]: isDrawn\n  //     }\n  //   }\n  // }\n  const coords = {};\n  const nodeReference = {};\n\n  // check coord of all to[] element\n  state.pathComponents.allIds.forEach((id) => {\n    const element = state.pathComponents.byId[id];\n    if (isPath[element.type]) {\n      const fromCoord = state.anchors.byId[element.from];\n      const toCoord = state.anchors.byId[element.to];\n\n      const fromCoordId = getCoordId(fromCoord);\n      const toCoordId = getCoordId(toCoord);\n\n      if (coords[fromCoordId] === undefined) {\n        coords[fromCoordId] = {\n          x: fromCoord.x.toFixed(2),\n          y: fromCoord.y.toFixed(2),\n          name: null,\n          startingPaths: [element.id],\n          endingPaths: [],\n          nodeAssociated: [],\n        };\n      } else if (!coords[fromCoordId].startingPaths.includes(element.id)) {\n        coords[fromCoordId].startingPaths.push(element.id);\n      }\n\n      if (coords[toCoordId] === undefined) {\n        coords[toCoordId] = {\n          x: toCoord.x.toFixed(2),\n          y: toCoord.y.toFixed(2),\n          name: null,\n          endingPaths: [element.id],\n          startingPaths: [],\n          nodeAssociated: [],\n        };\n      } else if (!coords[toCoordId].endingPaths.includes(element.id)) {\n        coords[toCoordId].endingPaths.push(element.id);\n      }\n    } else {\n      nodeReference[element.id] = {\n        name: null,\n        parent: null,\n        parentAnchor: null,\n        anchor: null,\n        associatedIds: [],\n      };\n      if (!isMultyPole[element.type]) {\n        const positionCoord = state.anchors.byId[element.position];\n        const positionCoordId = getCoordId(positionCoord);\n\n        if (coords[positionCoordId] === undefined) {\n          coords[positionCoordId] = {\n            x: positionCoord.x.toFixed(2),\n            y: positionCoord.y.toFixed(2),\n            name: null,\n            startingPaths: [],\n            endingPaths: [],\n            nodeAssociated: [element.id],\n          };\n        } else if (\n          !coords[positionCoordId].nodeAssociated.includes(element.id)\n        ) {\n          coords[positionCoordId].nodeAssociated.push(element.id);\n        }\n      }\n    }\n  });\n\n  // add node informations\n  state.weakLinks.forEach(({ anchorId, nodeId, name, nameAnchor }) => {\n    const coord = state.anchors.byId[anchorId];\n\n    if (\n      !coord.isNodePosition ||\n      !isMultyPole[\n        state.pathComponents.byId[state.anchors.byId[anchorId].nodeId].type\n      ]\n    ) {\n      const coordId = getCoordId(coord);\n      if (!coords[coordId].nodeAssociated.includes(nodeId)) {\n        coords[coordId].nodeAssociated.push(nodeId);\n      }\n      if (!nodeReference[nodeId].associatedIds.includes(coordId)) {\n        nodeReference[nodeId].associatedIds.push(coordId);\n      }\n    } else {\n      const childId = state.anchors.byId[anchorId].nodeId;\n      nodeReference[childId].parent = nodeId;\n      nodeReference[childId].anchor = nameAnchor;\n      nodeReference[childId].parentAnchor = name;\n      if (!nodeReference[nodeId].associatedIds.includes(childId)) {\n        nodeReference[nodeId].associatedIds.push(childId);\n      }\n    }\n  });\n\n  return [coords, nodeReference];\n};\n\nfunction getCircuitikz(state) {\n  const [coords, nodeReference] = initilizeCoords(state);\n\n  const drawnElements = {};\n  let nbOfCoordinateUsed = 0;\n  const nodeNumberOfNames = {};\n  const circuitText = [\"\\\\begin{circuitikz}\"];\n\n  const multiAnchorNodeIds = state.pathComponents.allIds\n    .filter((elementId) => {\n      const element = state.pathComponents.byId[elementId];\n      return isNode(element) && isMultyPole[element.type];\n    })\n    .sort((id1, id2) => {\n      if (nodeReference[id1].parent === null) {\n        return -1; //if they are both null (without parent) id1 is preferred (so we do not need to check id2)\n      }\n      if (nodeReference[id2].parent === null) {\n        return 1; //if we are here, it's that id1 is not null. but id2 is so we prefer it\n      }\n      if (nodeReference[id2].parent === id1) {\n        //id1 is parent of id2\n        return -1; //so 1 must be printed before 2\n      }\n      if (nodeReference[id1].parent === id2) {\n        //id2 is parent of id1\n        return -1; //so 2 must be printed before 1\n      }\n      return -1;\n    });\n\n  multiAnchorNodeIds.forEach((elementId) => {\n    const element = state.pathComponents.byId[elementId];\n\n    // get parent information for positioning\n    const positionInformations = {};\n    if (nodeReference[elementId].parent !== null) {\n      positionInformations.position = `${\n        nodeReference[nodeReference[elementId].parent].name\n      }.${nodeReference[elementId].parentAnchor}`;\n\n      positionInformations.anchor = nodeReference[elementId].anchor;\n    } else {\n      positionInformations.x = state.anchors.byId[element.position].x;\n      positionInformations.y = state.anchors.byId[element.position].y;\n    }\n\n    // check if need to create name\n    const nameNeeded = nodeReference[elementId].associatedIds.length > 0;\n    if (nameNeeded) {\n      const name = `${element.type}${nodeNumberOfNames[element.type] || 1}`;\n\n      circuitText.push(drawElement(element, positionInformations, name));\n\n      nodeReference[element.id].name = name;\n      nodeNumberOfNames[element.type] =\n        (nodeNumberOfNames[element.type] || 1) + 1;\n    } else {\n      circuitText.push(drawElement(element, positionInformations));\n    }\n\n    drawnElements[elementId] = true; //note that this node is ok\n  });\n\n  //END of drawing multi-pole nodes\n\n  // For each coord, we set name if it's a node anchor\n  state.weakLinks.forEach(({ anchorId, nodeId, name, nameAnchor }) => {\n    const coord = state.anchors.byId[anchorId];\n    const coordId = getCoordId(coord);\n\n    if (\n      coords[coordId] && //coord is a used coordinate (remove multipleAnchor node)\n      drawnElements[nodeId] && //parent is drawn (remove mono anchor node)\n      !coords[coordId].name && //name is not already attributed\n      nodeReference[nodeId].name //the parent has a name\n    ) {\n      coords[coordId].name = `${nodeReference[nodeId].name}.${name}`;\n    }\n  });\n\n  //START drawing children paths\n  multiAnchorNodeIds.forEach((nodeId) => {\n    nodeReference[nodeId].associatedIds.forEach((childId) => {\n      if (coords[childId] !== undefined) {\n        const [elementsToAdd, nbOfCreatedNames] = drawPathFromCoord(\n          childId,\n          coords,\n          state,\n          drawnElements,\n          nbOfCoordinateUsed\n        );\n\n        if (elementsToAdd.length > 0) {\n          nbOfCoordinateUsed += nbOfCreatedNames;\n          circuitText.push(elementsToAdd.join(\"\"));\n        }\n      }\n    });\n  });\n\n  //last pass over coords to plot every things\n  const coordsToPlot = Object.keys(coords);\n  while (coordsToPlot.length > 0) {\n    //remove the id to plot\n    const idToPlot = coordsToPlot.sort(compareCoord(drawElement, coords))[0];\n    var index = coordsToPlot.indexOf(idToPlot);\n    coordsToPlot.splice(index, 1);\n\n    //plot it\n    if (coords[idToPlot] !== undefined) {\n      const [elementsToAdd, nbOfCreatedNames] = drawPathFromCoord(\n        idToPlot,\n        coords,\n        state,\n        drawnElements,\n        nbOfCoordinateUsed\n      );\n\n      if (elementsToAdd.length > 0) {\n        nbOfCoordinateUsed += nbOfCreatedNames;\n        circuitText.push(elementsToAdd.join(\"\"));\n      }\n    }\n  }\n  circuitText.push(\"\\\\end{circuitikz}\");\n\n  return circuitText;\n}\n\n// 1. draw all nodes with more than 1 anchor\n// 2. draw path elements starting from those nodes (if ath encounter a 1 anchor node draw it)\n// 3. draw missing paths and nodes. start from coord with the most important nb of nodes undraw and the less ending to[] and follow path as long as possible\n\nexport default getCircuitikz;\n","import React from \"react\";\nimport { connect } from \"react-redux\";\n\nimport getCircuitikz from \"../redux/store/getCircuitikz\";\n\nimport DialogTitle from \"@material-ui/core/DialogTitle\";\nimport DialogContent from \"@material-ui/core/DialogContent\";\nimport DialogActions from \"@material-ui/core/DialogActions\";\nimport Button from \"@material-ui/core/Button\";\n\nconst copyCode = (code) => {\n  navigator.clipboard.writeText(code).then(\n    function () {},\n    function () {}\n  );\n};\n\nconst mapStateToProps = (state) => {\n  return { code: getCircuitikz(state) };\n};\n\nconst LatexDisplay = ({ code }) => (\n  <>\n    <DialogTitle>Your LaTEX code</DialogTitle>\n    <DialogContent>\n      <pre>\n        {code.slice(0, code.length - 1).join(\"\\n\\t\") +\n          \"\\n\" +\n          code[code.length - 1]}\n      </pre>\n    </DialogContent>\n    <DialogActions>\n      <Button\n        autoFocus\n        onClick={() => {\n          copyCode(\n            code.slice(0, code.length - 1).join(\"\\n\\t\") +\n              \"\\n\" +\n              code[code.length - 1]\n          );\n        }}\n      >\n        Copy\n      </Button>\n    </DialogActions>\n  </>\n);\n\nexport default connect(mapStateToProps, null)(LatexDisplay);\n","import React from \"react\";\nimport { connect } from \"react-redux\";\n\nimport { updateComponent } from \"../redux/actions\";\n\nimport List from \"@material-ui/core/List\";\nimport ListItem from \"@material-ui/core/ListItem\";\nimport ListItemText from \"@material-ui/core/ListItemText\";\nimport ListItemSecondaryAction from \"@material-ui/core/ListItemSecondaryAction\";\n\nimport Input from \"@material-ui/core/Input\";\nimport Checkbox from \"@material-ui/core/Checkbox\";\nimport Switch from \"@material-ui/core/Switch\";\nimport FormControlLabel from \"@material-ui/core/FormControlLabel\";\nimport TextField from \"@material-ui/core/TextField\";\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    handleInputChange: (id, name) => (value) => (event) =>\n      dispatch(\n        updateComponent(id, name, value === null ? event.target.value : value)\n      ),\n  };\n};\n\nconst mapStateToProps = (state) => {\n  if (\n    state.selection.length < 1 ||\n    !state.pathComponents.allIds.includes(state.selection[0])\n  ) {\n    return {};\n  }\n  const idOfInterest = state.selection[0];\n  return {\n    id: idOfInterest,\n    options: state.pathComponents.byId[idOfInterest],\n  };\n};\n\nconst inputElement = {\n  label: (value, update) => (\n    <ListItem>\n      <TextField\n        label=\"Label\"\n        value={value}\n        onKeyDown={(e) => e.stopPropagation()}\n        onChangeCapture={update(null)}\n      />\n    </ListItem>\n  ),\n  annotation: (value, update) => (\n    <ListItem>\n      <TextField\n        label=\"Annotation\"\n        value={value}\n        onKeyDown={(e) => e.stopPropagation()}\n        onChangeCapture={update(null)}\n      />\n    </ListItem>\n  ),\n  angle: (value, update) => (\n    <ListItem button>\n      <ListItemText primary=\"rotation\" />\n      <ListItemSecondaryAction>\n        <Input\n          value={value || 0}\n          onKeyDown={(e) => e.stopPropagation()}\n          onChangeCapture={update(null)}\n          inputProps={{\n            step: 5,\n            min: -180,\n            max: 180,\n            type: \"number\",\n          }}\n        />\n      </ListItemSecondaryAction>\n    </ListItem>\n  ),\n  mirror: (value, update) => (\n    <ListItem>\n      <FormControlLabel\n        control={\n          <Switch checked={value} onChange={update(!value)} name=\"mirror\" />\n        }\n        label=\"mirror\"\n      />\n    </ListItem>\n  ),\n  invert: (value, update) => (\n    <ListItem>\n      <FormControlLabel\n        control={\n          <Switch checked={value} onChange={update(!value)} name=\"invert\" />\n        }\n        label=\"Invert\"\n      />\n    </ListItem>\n  ),\n  currant: (value, update) => (\n    <>\n      <ListItem button>\n        <ListItemText primary=\"Currant\" />\n        <ListItemSecondaryAction>\n          <Checkbox\n            checked={value.show}\n            onChange={update({ ...value, show: !value.show })}\n            inputProps={{ \"aria-label\": \"primary checkbox\" }}\n          />\n        </ListItemSecondaryAction>\n      </ListItem>\n      <ListItem>\n        <TextField\n          disabled={!value.show}\n          label=\"Currant name\"\n          value={value.currantText}\n          onKeyDown={(e) => e.stopPropagation()}\n          onChangeCapture={(e) =>\n            update({ ...value, currantText: e.target.value })()\n          }\n        />\n      </ListItem>\n      <ListItem>\n        <FormControlLabel\n          disabled={!value.show}\n          control={\n            <Switch\n              checked={value.currantIsForward}\n              onChange={update({\n                ...value,\n                currantIsForward: !value.currantIsForward,\n              })}\n              name=\"arrow direction\"\n            />\n          }\n          label=\"direction\"\n        />\n      </ListItem>\n      <ListItem>\n        <FormControlLabel\n          disabled={!value.show}\n          control={\n            <Switch\n              checked={value.currantIsAfter}\n              onChange={update({\n                ...value,\n                currantIsAfter: !value.currantIsAfter,\n              })}\n              name=\"currant position\"\n            />\n          }\n          label=\"arrow position\"\n        />\n      </ListItem>\n      <ListItem>\n        <FormControlLabel\n          disabled={!value.show}\n          control={\n            <Switch\n              checked={value.currantIsAbove}\n              onChange={update({\n                ...value,\n                currantIsAbove: !value.currantIsAbove,\n              })}\n              name=\"text position\"\n            />\n          }\n          label=\"text position\"\n        />\n      </ListItem>\n    </>\n  ),\n};\n\nconst ElementOptions = ({ handleInputChange, id, options = null }) => {\n  if (options === null) {\n    return null;\n  }\n  return (\n    <List>\n      {Object.keys(options)\n        .map((name) => [\n          name,\n          Object.keys(inputElement).findIndex((n) => n === name),\n        ])\n        .filter(([, index]) => index >= 0)\n        .sort(([, i1], [, i2]) => i1 - i2)\n        .map(([name]) => (\n          <div key={name}>\n            {inputElement[name](options[name], handleInputChange(id, name))}\n          </div>\n        ))}\n    </List>\n  );\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(ElementOptions);\n","import React, { useEffect, useState } from \"react\";\nimport { connect } from \"react-redux\";\nimport { MODE_DRAG, MODE_SELECT } from \"./redux/store/interactionModes\";\n\nimport Container from \"./container/index.js\";\nimport LatexDisplay from \"./container/latexDisplay\";\nimport ElementOptions from \"./container/elementOptions\";\n\nimport components, { isPath } from \"./components\";\n\nimport Drawer from \"@material-ui/core/Drawer\";\nimport AppBar from \"@material-ui/core/AppBar\";\nimport Toolbar from \"@material-ui/core/Toolbar\";\nimport Typography from \"@material-ui/core/Typography\";\n\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport CssBaseline from \"@material-ui/core/CssBaseline\";\nimport List from \"@material-ui/core/List\";\nimport ListItem from \"@material-ui/core/ListItem\";\nimport ListItemText from \"@material-ui/core/ListItemText\";\n\nimport Button from \"@material-ui/core/Button\";\nimport Dialog from \"@material-ui/core/Dialog\";\n\nimport {\n  startSelect,\n  startCreatePathElement,\n  startCreateNodeElement,\n  splitAnchor,\n  stackSelectedAnchors,\n  deleteElement,\n} from \"./redux/actions\";\n\nconst drawerWidth = 180;\nconst optionDrawerWidth = 280;\n\nconst useStyles = makeStyles((theme) => ({\n  root: {\n    display: \"flex\",\n  },\n  appBar: {\n    zIndex: theme.zIndex.drawer + 1,\n  },\n  toolBar: {\n    justifyContent: \"space-between\",\n  },\n  drawer: {\n    width: drawerWidth,\n    flexShrink: 0,\n  },\n  drawerPaper: {\n    width: drawerWidth,\n  },\n  drawerContainer: {\n    overflow: \"auto\",\n  },\n  optionDrawer: {},\n  optionDrawerPaper: { width: optionDrawerWidth },\n  content: {\n    flexGrow: 1,\n    padding: theme.spacing(3),\n  },\n}));\n\nconst mapStateToProps = (state) => {\n  return {\n    mode: state.mode,\n    selection: state.selection,\n    pathIds: state.pathComponents.allIds,\n  };\n};\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    startSelect: () => dispatch(startSelect()),\n    startCreatePathElement: (elementType) =>\n      dispatch(startCreatePathElement(elementType)),\n    startCreateNodeElement: (elementType) =>\n      dispatch(startCreateNodeElement(elementType)),\n    splitAnchor: () => dispatch(splitAnchor()),\n    stackSelectedAnchors: (direction) =>\n      dispatch(stackSelectedAnchors(direction)),\n    deleteElement: (selection) => {\n      dispatch(deleteElement(selection));\n    },\n  };\n};\n\nfunction App({\n  mode,\n  selection,\n  pathIds,\n  startSelect,\n  startCreatePathElement,\n  startCreateNodeElement,\n  splitAnchor,\n  stackSelectedAnchors,\n  deleteElement,\n}) {\n  const classes = useStyles();\n  const [showCode, setShowCode] = useState(false);\n\n  useEffect(() => {\n    const handleKeyDown = (event) => {\n      switch (event.key) {\n        case \"ArrowRight\":\n          stackSelectedAnchors(\"R\");\n          break;\n        case \"ArrowLeft\":\n          stackSelectedAnchors(\"L\");\n          break;\n        case \"ArrowUp\":\n          stackSelectedAnchors(\"U\");\n          break;\n        case \"ArrowDown\":\n          stackSelectedAnchors(\"D\");\n          break;\n        case \"s\":\n          splitAnchor();\n          break;\n        case \"Delete\":\n          deleteElement(selection);\n          break;\n        default:\n          console.log(event.key);\n          break;\n      }\n    };\n    document.addEventListener(\"keydown\", handleKeyDown);\n\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyDown);\n    };\n  }, [splitAnchor, stackSelectedAnchors, deleteElement, selection]);\n\n  return (\n    // TODO : Proper listen key event\n    <div className={classes.root} tabIndex=\"0\" onMouseDown={startSelect}>\n      <CssBaseline />\n\n      <AppBar position=\"fixed\" className={classes.appBar}>\n        <Toolbar className={classes.toolBar}>\n          <Typography variant=\"h6\" noWrap>\n            Clipped drawer\n          </Typography>\n\n          <Button color=\"inherit\" onClick={() => setShowCode(true)}>\n            LaTEX\n          </Button>\n        </Toolbar>\n      </AppBar>\n      <Drawer\n        className={classes.drawer}\n        variant=\"permanent\"\n        classes={{\n          paper: classes.drawerPaper,\n        }}\n      >\n        <Toolbar />\n        <div className={classes.drawerContainer}>\n          <List>\n            {Object.keys(components).map((name) => (\n              <ListItem\n                button\n                key={name}\n                onMouseDown={(event) => {\n                  event.stopPropagation();\n                  if (isPath[name]) {\n                    startCreatePathElement(name);\n                  } else {\n                    startCreateNodeElement(name);\n                  }\n                }}\n              >\n                <ListItemText primary={name} />\n              </ListItem>\n            ))}\n          </List>\n        </div>\n      </Drawer>\n      <Drawer\n        anchor=\"right\"\n        variant=\"persistent\"\n        open={\n          (mode === MODE_SELECT || mode === MODE_DRAG) &&\n          selection.length === 1 &&\n          pathIds.includes(selection[0])\n        }\n        className={classes.optionDrawer}\n        classes={{\n          paper: classes.optionDrawerPaper,\n        }}\n        // catch mousedown in element options\n        onMouseDown={(event) => event.stopPropagation()}\n      >\n        <Toolbar />\n        <ElementOptions />\n      </Drawer>\n      <main className={classes.content}>\n        <Toolbar />\n        <Container />\n      </main>\n\n      <Dialog\n        open={showCode}\n        onClose={() => {\n          setShowCode(false);\n        }}\n      >\n        <LatexDisplay />\n      </Dialog>\n    </div>\n  );\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Provider } from \"react-redux\";\nimport store from \"./redux/store\";\n\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}